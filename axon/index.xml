<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Axons on 月亮</title><link>https://halley-eng.github.io/halley/axon/</link><description>Recent content in Axons on 月亮</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Wed, 25 Nov 2020 23:36:25 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/axon/index.xml" rel="self" type="application/rss+xml"/><item><title>集群命令总线 DistributedCommandBus SpringCloud扩展实现</title><link>https://halley-eng.github.io/halley/axon/%E9%9B%86%E7%BE%A4%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF-distributedcommandbus-springcloud%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 25 Nov 2020 23:36:25 +0800</pubDate><guid>https://halley-eng.github.io/halley/axon/%E9%9B%86%E7%BE%A4%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF-distributedcommandbus-springcloud%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0/</guid><description>集群命令总线用于消息在多个节点之间的转发, SpringCloud扩展实现使用一致性hash算法, 有效的将消息的压力负载到多个节点上面;
集群命令总线相对于简单命令总线多了路由器和连接器;
消息派发过程 通过路由器找到目标节点 destination; 使用连接器发送出去 找不到目标节点则抛出异常; @Override public &amp;lt;C&amp;gt; void dispatch(CommandMessage&amp;lt;C&amp;gt; command) { if (defaultCommandCallback != null) { dispatch(command, defaultCommandCallback); return; } LoggingCallback loggingCallback = LoggingCallback.INSTANCE; // 没有消息监控器 则直接派发; if (NoOpMessageMonitor.INSTANCE.equals(messageMonitor)) { // 派发拦截器 CommandMessage&amp;lt;? extends C&amp;gt; interceptedCommand = intercept(command); // 路由找节点; Optional&amp;lt;Member&amp;gt; optionalDestination = commandRouter.findDestination(interceptedCommand); if (optionalDestination.isPresent()) { Member destination = optionalDestination.get(); try { // 发送到目标节点; connector.send(destination, interceptedCommand); } catch (Exception e) { destination.</description></item><item><title>简单命令总线 SimpleCommandBus</title><link>https://halley-eng.github.io/halley/axon/%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF-simplecommandbus/</link><pubDate>Wed, 25 Nov 2020 23:35:04 +0800</pubDate><guid>https://halley-eng.github.io/halley/axon/%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF-simplecommandbus/</guid><description>架构图 构建处理器 Builder 支持配置项如下:
事务管理器: transactionManager 监控器: messageMonitor 回滚配置: rollbackConfiguration 冲突检测器: duplicateCommandHandlerResolver 默认命令处理器: defaultCommandCallback 它们的默认配置如下:
private TransactionManager transactionManager = NoTransactionManager.INSTANCE; private MessageMonitor&amp;lt;? super CommandMessage&amp;lt;?&amp;gt;&amp;gt; messageMonitor = NoOpMessageMonitor.INSTANCE; private RollbackConfiguration rollbackConfiguration = RollbackConfigurationType.UNCHECKED_EXCEPTIONS; private DuplicateCommandHandlerResolver duplicateCommandHandlerResolver = DuplicateCommandHandlerResolution.logAndOverride(); private CommandCallback&amp;lt;Object, Object&amp;gt; defaultCommandCallback = LoggingCallback.INSTANCE; 这里提供的默认处理器是什么都不做, 但是调用方就不用处理NPE问题了; 比如事务处理器
public enum NoTransactionManager implements TransactionManager { /** * Singleton instance of the TransactionManager */ INSTANCE; /** * Returns the singleton instance of this TransactionManager * * @return the singleton instance of this TransactionManager */ public static TransactionManager instance() { return INSTANCE; } @Override public Transaction startTransaction() { return TRANSACTION; } private static final Transaction TRANSACTION = new Transaction() { @Override public void commit() { //no op } @Override public void rollback() { //no op } }; } 订阅 (subscribe) 对冲突处理提供通过自定义冲突处理器，提供定制化能力。</description></item><item><title>Axon总揽</title><link>https://halley-eng.github.io/halley/axon/axon%E6%80%BB%E6%8F%BD/</link><pubDate>Wed, 25 Nov 2020 23:34:02 +0800</pubDate><guid>https://halley-eng.github.io/halley/axon/axon%E6%80%BB%E6%8F%BD/</guid><description>Messaging Concepts(消息概念) Axon 核心 概念之一是使用消息来做组件中的通信, 这样可以使得组件间位置透明, 以此做到灵活扩缩容;
所有的消息都实现Message接口, 不同的类型的消息可以做到明显区分
所有消息包含 payload、meta data 和 unique identifier 三个部分; payload: 消息体 主要是包含类型 和 对象数据组成; meta data: 描述消息体的上下文 可以用来存储tracing信息 &amp;ndash; 辅助根因分析 存储security context 注意:
所有的消息都是不可修改的(immutable), 去消息中存储数据, 意味着基于之前的消息创建一个新的消息; 这样可以保证消息在多线程和分布式环境的并发安全性; 命令(Commands) 命令用来描述更改程序状态的意图, 通常为CommandMessage接口的实现类;
命令总是有唯一的一个目标, 它不关心哪个组件处理该命令或者是该组件在哪里, 但是可能关心其输出, 所以通常命令消息通过 Command Bus 发送, 并且支持得到一个返回值;
事件(Events) 事件用来描述程序内部发生的事情, 通常的事件源为Aggregate, 在Axon中, 事件可以是所有的对象, 所以强烈建议将所有的事件都支持序列化;
当事件被派发的时候, 事件被包装成EventMessage, 实际的消息类型将会取决于事件来源
来自Aggregate: DominEventMessage 除了所有事件都有的唯一标识, 该事件还包含 类型(type) 时间戳(timestamp) sequence number: 发射源发送事件的序号; 其他: EventMessage 注意：</description></item></channel></rss>