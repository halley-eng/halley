<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>源码阅读s - 月亮</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content><meta property="og:title" content="源码阅读s"><meta property="og:description" content="about Java、Algorithm and so on"><meta property="og:type" content="website"><meta property="og:url" content="https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><meta property="og:updated_time" content="2020-12-22T21:39:16+08:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/halley/css/style.css><link rel=alternate type=application/rss+xml href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/index.xml title=月亮><link rel="shortcut icon" href=/halley/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/halley/ title=月亮 rel=home><div class="logo__item logo__text"><div class=logo__title>月亮</div><div class=logo__tagline>每天进步一点点</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/halley/jdk/><i class="fa fa-road"></i><span class=menu__text>JDK</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/%E7%AE%97%E6%B3%95/><i class="fa fa-road"></i><span class=menu__text>算法</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/axon/><i class="fa fa-road"></i><span class=menu__text>Axon</span>
<span class=alert></span></a></li><li class="menu__item menu__item--active"><a class=menu__link href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/><i class="fa fa-road"></i><span class=menu__text>源码阅读</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/about/><span class=menu__text>关于作者</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class="main list" role=main><header class=main__header><h1 class=main__title>源码阅读s</h1></header><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/configuration%E6%B3%A8%E8%A7%A3%E4%B9%8Bconfigurationclasspostprocessor/ rel=bookmark>Configuration注解之ConfigurationClassPostProcessor</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-12-22T21:39:16+08:00>December 22, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">Configuration 注解之 ConfigurationClassPostProcessor 运行时机 BeanDefinitionRegistryPostProcessor 钩子 通过实现 BeanDefinitionRegistryPostProcessor 接口, 可以在IOC容器刷新阶段的调用, 如下方法
/** * Derive further bean definitions from the configuration classes in the registry. */ @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { // 1. 保证IOC容器只能处理一次; int registryId = System.identityHashCode(registry); if (this.registriesPostProcessed.contains(registryId)) { throw new IllegalStateException( "postProcessBeanDefinitionRegistry already called on this post-processor against " + registry); } if (this.factoriesPostProcessed.contains(registryId)) { throw new IllegalStateException( "postProcessBeanFactory already called on this post-processor against " + registry); } this.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/jdbctemplate%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81/ rel=bookmark></a></h3></header><div class="content list__excerpt post__content clearfix">JdbcTemplate 相关源码 数据行映射到对象 BeanPropertyRowMapper#mapRow /** * Extract the values for all columns in the current row. * &lt;p>Utilizes public setters and result set meta-data. * @see java.sql.ResultSetMetaData */ @Override public T mapRow(ResultSet rs, int rowNumber) throws SQLException { // 1. 构建并初始化BeanWrapper BeanWrapperImpl bw = new BeanWrapperImpl(); initBeanWrapper(bw); // 2. 构建实例; T mappedObject = constructMappedInstance(rs, bw); // 3. 封装到 Spring 的BeanWrapper bw.setBeanInstance(mappedObject); // 4. 循环解析每一列到BeanWrapper; ResultSetMetaData rsmd = rs.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E6%BA%90%E7%A0%81/ rel=bookmark></a></h3></header><div class="content list__excerpt post__content clearfix">MyBatis 源码 Mapper代理创建 org.mybatis.spring.mapper.MapperFactoryBean#getObject
@Override public T getObject() throws Exception { return getSqlSession().getMapper(this.mapperInterface); } 这里的配置通常是 SqlSessionTemplate 它是 spring-mybatis 实现的线程安全会话创建和生命周期管理类;
后期 SqlSession 的方法都会通过他的拦截器 SqlSessionTemplate.SqlSessionInterceptor 详细如下:
Sql Session 拦截器接收sql参数并执行 SqlSessionTemplate.SqlSessionInterceptor
该拦截器负责
封装 SqlSession 的获取 调用 SqlSession 的相关方法，完成sql执行的生命周期; private class SqlSessionInterceptor implements InvocationHandler { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 1. 获取会话 SqlSession sqlSession = getSqlSession( SqlSessionTemplate.this.sqlSessionFactory, // 每个工厂么每个线程都能仅能找到唯一一个 SqlSession SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try { // 2.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E8%A7%A3%E6%9E%90xml%E5%92%8C%E5%8A%A8%E6%80%81sql/ rel=bookmark></a></h3></header><div class="content list__excerpt post__content clearfix">mybatis解析xml和动态sql mybatis 如何解析xml文件 support.DaoSupport#afterPropertiesSet MapperFactoryBean#checkDaoConfig 总之， MapperFactoryBean该工厂bean初始化后就会注册到 MapperRegistry org.apache.ibatis.binding.MapperRegistry#addMapper 在触发解析xml MapperAnnotationBuilder#parse MapperAnnotationBuilder#loadXmlResource MapperBuilderAssistant#addMappedStatement
动态sql解析 DynamicSqlSource#getBoundSql
根据参数解析动态sql生成 BoundSql
public BoundSql getBoundSql(Object parameterObject) { BoundSql boundSql = sqlSource.getBoundSql(parameterObject); List&lt;ParameterMapping> parameterMappings = boundSql.getParameterMappings(); if (parameterMappings == null || parameterMappings.isEmpty()) { boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject); } // check for nested result maps in parameter mappings (issue #30) for (ParameterMapping pm : boundSql.getParameterMappings()) { String rmId = pm.getResultMapId(); if (rmId != null) { ResultMap rm = configuration.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/shardingspare%E6%BA%90%E7%A0%81/ rel=bookmark></a></h3></header><div class="content list__excerpt post__content clearfix">shardingsphere源码解析 使用方法 导入包
&lt;dependency> &lt;groupId>org.apache.shardingsphere&lt;/groupId> &lt;artifactId>shardingsphere-jdbc-core&lt;/artifactId> &lt;version>${shardingsphere.version}&lt;/version> &lt;/dependency> 配置路由规则 比如两库两表
// Configure actual data sources Map&lt;String, DataSource> dataSourceMap = new HashMap&lt;>(); // Configure the first data source BasicDataSource dataSource1 = new BasicDataSource(); dataSource1.setDriverClassName("com.mysql.jdbc.Driver"); dataSource1.setUrl("jdbc:mysql://localhost:3306/ds0"); dataSource1.setUsername("root"); dataSource1.setPassword(""); dataSourceMap.put("ds0", dataSource1); // Configure the second data source BasicDataSource dataSource2 = new BasicDataSource(); dataSource2.setDriverClassName("com.mysql.jdbc.Driver"); dataSource2.setUrl("jdbc:mysql://localhost:3306/ds1"); dataSource2.setUsername("root"); dataSource2.setPassword(""); dataSourceMap.put("ds1", dataSource2); // Configure order table rule ShardingTableRuleConfiguration orderTableRuleConfig = new ShardingTableRuleConfiguration("t_order", "ds${0..1}.t_order${0..1}"); // Configure database sharding strategy orderTableRuleConfig.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/springframework%E4%B9%8Bautowiredannotationbeanpostprocessor/ rel=bookmark></a></h3></header><div class="content list__excerpt post__content clearfix">支持注入的注解类型 从如下构造方法可知其支持的给两种注解类型
Autowired Value /** * Create a new AutowiredAnnotationBeanPostProcessor * for Spring's standard {@link Autowired} annotation. * &lt;p>Also supports JSR-330's {@link javax.inject.Inject} annotation, if available. */ @SuppressWarnings("unchecked") public AutowiredAnnotationBeanPostProcessor() { this.autowiredAnnotationTypes.add(Autowired.class); this.autowiredAnnotationTypes.add(Value.class); try { this.autowiredAnnotationTypes.add((Class&lt;? extends Annotation>) ClassUtils.forName("javax.inject.Inject", AutowiredAnnotationBeanPostProcessor.class.getClassLoader())); logger.trace("JSR-330 'javax.inject.Inject' annotation found and supported for autowiring"); } catch (ClassNotFoundException ex) { // JSR-330 API not available - simply skip. } } 注入的时机 Value 注解和 Autowire 都是由 AutowiredAnnotationBeanPostProcessor 负责解析依赖并注入的 但是Value的数据源为需要手动注册 PropertySourcesPlaceholderConfigurer</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/ rel=bookmark></a></h3></header><div class="content list__excerpt post__content clearfix">Spring 解析注解 注解中的属性方法定义 AttributeMethods#isAttributeMethod
/** * 属性方法的定义是 无参数 有返回值得方法; * @param method * @return */ private static boolean isAttributeMethod(Method method) { return (method.getParameterCount() == 0 && method.getReturnType() != void.class); } 获取注解中的所有属性方法 private static AttributeMethods compute(Class&lt;? extends Annotation> annotationType) { // 1. 收集所有方法 Method[] methods = annotationType.getDeclaredMethods(); int size = methods.length; // 2. 过滤得到属性方法; for (int i = 0; i &lt; methods.length; i++) { if (!isAttributeMethod(methods[i])) { methods[i] = null; size--; } } if (size == 0) { return NONE; } // 3.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E8%A7%A3%E6%9E%90configuration%E7%B1%BB/ rel=bookmark></a></h3></header><div class="content list__excerpt post__content clearfix">解析所有配置类 ConfigurationClassParser#parse(Set)
public void parse(Set&lt;BeanDefinitionHolder> configCandidates) { // 1. 扫描所有配置类; for (BeanDefinitionHolder holder : configCandidates) { BeanDefinition bd = holder.getBeanDefinition(); try { // 1.1 带注解的解析; if (bd instanceof AnnotatedBeanDefinition) { parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } // 1.2 else if (bd instanceof AbstractBeanDefinition && ((AbstractBeanDefinition) bd).hasBeanClass()) { parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); } // 1.3 else { parse(bd.getBeanClassName(), holder.getBeanName()); } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( "Failed to parse configuration class [" + bd.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E6%B3%A8%E8%A7%A3enabletransactionmanagement%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/ rel=bookmark></a></h3></header><div class="content list__excerpt post__content clearfix">事务注解的解析流程
ConfigurationClassPostProcessor 解析配置类 发现注解类型 EnableTransactionManagement 根据注解找到其对应的 Selector 实现 TransactionManagementConfigurationSelector 解析器调用 selector 实现父类 AdviceModeImportSelector 的 selectImports(AnnotationMetadata importingClassMetadata)方法 AdviceModeImportSelector 解析出通知模式后 调用selector实现类 的 selectImports(AdviceMode adviceMode) 第四部源码如下:
根据通知模式模式(AspectJ/Proxy)路由不同的配置类; AdviceModeImportSelector#selectImports(AnnotationMetadata)
@Override public final String[] selectImports(AnnotationMetadata importingClassMetadata) { // 1. 查询当前类作为别人的父类是, 子类给的泛型参数是什么, 它是当前类要处理的注解类型; Class&lt;?> annoType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class); // 2. 从源配置类中查询出来, 注解参数实际对象; AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType); if (attributes == null) { throw new IllegalArgumentException(String.format( "@%s is not present on importing class '%s' as expected", annoType.</div></article></main></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH... name=q aria-label=SEARCH...></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://halley-eng.github.io/halley/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E9%A2%98%E7%9B%AE/>回溯题目</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/>螺旋矩阵</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E9%A2%98%E7%9B%AE%E7%AF%87/>分治题目篇</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/>扑克牌问题</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F_1356/>根据数字二进制下1的数目排序_1356</a></li></ul></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2020 月亮.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/halley/js/menu.js></script></body></html>