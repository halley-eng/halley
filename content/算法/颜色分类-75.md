---
title: "颜色分类 75"
date: 2020-10-07T10:37:33+08:00
draft: false
---

### 75. 颜色分类

75. 颜色分类
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:

输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
进阶：

一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？


* * *



#### 双指针法

思路是:
   使用两个指针left, right, 和另外一个指针 i 扫描为分类区域;
   其中
   1. left 定义最左面放置数字“0”的区间的右边界;
   2. right定义最右面放置数字“2”的区间的左边界;
   
   循环过程中通过迭代i,将0和2交换到左右区间, 直到 i > right得到期望的结果。
   
   

我们先给出源码, 然后通过循环不变式证明while循环的正确性; 

![bdc3615e2c87a65627a10969cd27aaca.png](evernotecid://0C0C6CA7-E0B1-4D07-A08B-2457E22E1166/appyinxiangcom/2181761/ENResource/p208)

```java


  private static void sortColor(int[] color) {

    // left : 下一个0 将要放置的位置;   [-oo  , left) 
    // right: 下一个2 将要放置的位置;   (right,  +oo]
    // i : 待分类的元素位置;          [left, i) 存放数据 1 ( 且left < i有效,  否则表示为检测到1)
    //                           [i, right] 为未分类区间;
    // 当未分类区间为空时候终止, 即 i > right, 最后一个未分类元素为 i == right;
    int i = 0, left = 0, right = color.length - 1;

    while (i <= right) {

      if (color[i] == 0) {    // 遇到0, 将其交换到前面, 这是i交换过来的只能是1
        ArrayUtils.swap(color, i++, left++);
      } else if (color[i] == 1) {
        i++;
      } else {
        ArrayUtils.swap(color, i, right--); // 遇到2交换到尾巴;
      }
    }
  }

```


##### 证明循环正确性：

首先根据题意划分数据分布区间:
    
    区间A:  [-oo  , left) 存放 0
    区间B:  (right,  +oo] 存放 2   
    区间C:  [left, i) 存放数据 1, （左右边界同时满足才是有效区间, 即left < i有效,  否则表示未检测到1）
    区间D:  [i, right] 为未分类区间
    
    在数组中的顺序如下: 
        [区间A) [区间C) [区间D]  [区间B]
        [0区间) [1区间) [未分类] [2区间]


循环不变式：
    
    如果还有未分类的元素那么其一定存在区间D, 否则根据其值分配到区间 A、B、C

初始化：
    
    第一轮循环开始之前, 所有元素元素都未曾分类, 根据i,right的初始条件,可知: 
    区间D:  [0, len - 1] 
    显然满足循环不变式
 
迭代保持：
    
    如果发现color[i] == 0, 则  ArrayUtils.swap(color, i++, left++);
       相关区间改变如下:
       区间A : 新增元素调整左边界 left
       区间C : 左边界+1 删除元素, 右边界+1新增元素, 但是该区间依然存储着所有的 1
       区间D : 左边界+1 删除元素， 因为本次对新元素进行了分类
       综上, 循环不变式成立;
    同理可证, 其他也能保持循环不变式成立;   

终止：
　　结束时发生了什么？ 
   i > right, 此时未分类区间为空, 根据迭代保持部分的分析, 每一次未分类区间的删除, 都能保持循环不变式成立, 所以能够正确的将所有的未分类元素进行分类排序; 

#### 为什么while循环中为<=
    区间A:  [-oo  , left) 存放 0
    区间D:  [i, right] 为未分类区间

    当 left == i 是, 其实i这个元素还是在区间D中, 就是未处理元素, 当然要去执行循环内过程;  

#### 说明不会出现死循环
    因为条件1和2 会i++, 条件3会right--；
    因此每次while的执行肯定会压缩区间[i, right]
    最终一定会让 i>right 满足





综上, 为今天的第一道题目 《75. 颜色分类》 下面是讨论环节


