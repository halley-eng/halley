---
title: "重排链表 143"
date: 2020-10-21T00:00:38+08:00
draft: false
---

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
        if(head == null) return;
        // 1. 找中点;
        ListNode mid = findMiddle(head);

        // 2. 反转链表l2; 
        // 2.1 拆分成两个链表; 
        ListNode l1 = head,  l2 = mid.next; 
        mid.next = null;
        // 2.2 反转链表l2
        l2 = reverse(l2);
    
        // 3. 合并链表l1, l2; 
        mergeList(l1, l2);
    }

    ListNode findMiddle(ListNode cur) {
        ListNode fast = cur, slow = cur;
        while(fast.next != null && fast.next.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }
        return slow;
    }   

    ListNode reverse(ListNode cur) {
         
         ListNode last = null;
         while(cur != null){
            ListNode next = cur.next;
            cur.next = last;
            last = cur;
            cur = next;
         }
         return last;
    }

    void mergeList(ListNode l1, ListNode l2){

          while(l1 != null && l2 != null){
               // 缓存两后缀; 
               ListNode l1Next = l1.next;
               ListNode l2Next = l2.next;
               // 修改两个节点的next属性;
               l1.next = l2;
               l2.next = l1Next;
               // 更新下次将要处理的两个节点的引用, 
               l1 = l1Next;
               l2 = l2Next;
          }  
    }

}


