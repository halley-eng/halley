---
title: "螺旋矩阵"
date: 2020-11-25T23:07:32+08:00
draft: false
---

#### 螺旋矩阵

* 题目描述

   给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。


```
    示例 1:

    输入:
    [
     [ 1, 2, 3 ],
     [ 4, 5, 6 ],
     [ 7, 8, 9 ]
    ]
    输出: [1,2,3,6,9,8,7,4,5]
    示例 2:

    输入:
    [
      [1, 2, 3, 4],
      [5, 6, 7, 8],
      [9,10,11,12]
    ]
    输出: [1,2,3,4,8,12,11,10,9,5,6,7]

```
    

* 算法思想:
    * 前提: 
        * 由起点坐标、方向、位移可以定义矩阵中的唯一一条线段, 并且可知当前路径下的所有坐标;
    * 螺旋过程可以抽象为: 访问多条首位相连的线段,并且这些线段有如下特征:
        * 起点坐标可知: 
            * 因多条路线首尾相连,所以下一个线段的起点为上一个线段的尾巴;
        * 方   向可知: 
            * 总是按照向右、 向下、 向左、 向上循环切换
            * 总是可以根据当前线段的方向,修正之后矩阵的参数:
                * 横向: 高度-1
                * 纵向: 宽度-1
        * 位   移可知:
            * 横向位移为矩阵的宽度;
            * 纵向位移为矩阵的高度;
           
        * 总位移为矩阵的面积;
               
    * 结论: 我们可以根据初始起点坐标、方向、位移螺旋得到矩阵中所有坐标;

    
* 复杂度分析

        时间复杂度： O(N^2),其中 N 是输入矩阵所有元素的个数。
        空间复杂度： O(N)，存储结果集result。


* 源码实现
```java

    public List<Integer> spiralOrder(int[][] matrix) {

        List<Integer> result = new ArrayList<>();
        int height = matrix.length, width = height == 0 ? 0 : matrix[0].length;
        int size = height * width;

        int[] dirX = {0, 1, 0, -1};
        int[] dirY = {1, 0, -1, 0};

        // 初始化起点坐标:(0,-1) 方向:向右;
        int x = 0, y = -1, dir = 0;
        for (int step, total = 0; total < size; total += step) {

            // 根据方向得到对应的位移, 并修正此后矩阵的参数(此后线段的长度)
            if (dir == 0 || dir == 2) {
                step = width;       
                height--;           
            } else {
                step = height;      
                width--;            
            }
            // 此前确定了起点坐标、方向和位移, 就可以得到当前线段的所有坐标,并输出到结果集;
            for (int i = step; i > 0; i--) {
                x += dirX[dir];
                y += dirY[dir];
                result.add(matrix[x][y]);
            }
            // 调整下一条线段方向
            dir = ++dir % 4;
        }

        return result;
    }

```
