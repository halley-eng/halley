<!doctype html><html class=no-js lang=en><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>月亮惹的祸</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content="about Java、Algorithm and so on"><meta property="og:title" content="月亮惹的祸"><meta property="og:description" content="about Java、Algorithm and so on"><meta property="og:type" content="website"><meta property="og:url" content="https://halley-eng.github.io/halley/"><meta property="og:updated_time" content="2020-11-25T21:44:15+08:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/halley/css/style.css><link rel=alternate type=application/rss+xml href=/halley/index.xml title=月亮惹的祸><link rel="shortcut icon" href=/halley/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/halley/ title=月亮惹的祸 rel=home><div class="logo__item logo__text"><div class=logo__title>月亮惹的祸</div><div class=logo__tagline>时间过去总得留下些痕迹</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/halley/jdk/><i class="fa fa-road"></i><span class=menu__text>JDK</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/%E7%AE%97%E6%B3%95/><i class="fa fa-road"></i><span class=menu__text>算法</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/about/><span class=menu__text>关于作者</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class="main list" role=main><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-executorcompletionservice/ rel=bookmark>并发编程框架 ExecutorCompletionService</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-25T21:44:15+08:00>November 25, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">提交任务 public Future&lt;V> submit(Callable&lt;V> task) { if (task == null) throw new NullPointerException(); // 创建任务; RunnableFuture&lt;V> f = newTaskFor(task); // 封装任务并将其提交到执行器; executor.execute(new QueueingFuture(f)); return f; } 封装任务是为了在任务执行完毕后能够接收任务完成信号
/** * FutureTask extension to enqueue upon completion */ private class QueueingFuture extends FutureTask&lt;Void> { QueueingFuture(RunnableFuture&lt;V> task) { super(task, null); this.task = task; } // 任务完成后 将任务添加到完成队列; protected void done() { completionQueue.add(task); } private final Future&lt;V> task; } 完成任务的获取 任务的获取主要是封装了queue的api 支持三种模式</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E7%8B%AC%E5%8D%A0%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81/ rel=bookmark>并发编程框架 AbstractQueuedSynchronizer 独占和共享锁</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-25T21:39:51+08:00>November 25, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">独占锁加锁(不响应超时和中断) 通过互斥量state获取锁: 尝试使用CAS更改状态,
如果能够获取成功, 则直接获取锁, 退出; 获取失败, 进入等待队列 addWaiter(Node.EXCLUSIVE) acquireQueued public final void acquire(int arg) { /** * {@link ReentrantLock.NonfairSync#tryAcquire(int)} 非公平方式获取锁 * * 1. 先尝试(使用CAS)获独占锁; * 2. 没有获得独占锁, 将自己作为一个独占节点并加入等待队列, * 之后在 acquireQueued 中进入不断等待的时期; * */ if (!tryAcquire(arg) && // 先尝试获取独占锁, 如果没有申请到锁 才往下走 // 1. 将当前线程加入到同步队列,并且其占用模式为独占形式 // 2. 当前线程wait并等待自己的节点的状态 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 获取锁 获取锁的函数如下, 其需要子类，根据场景不同(是否公平锁、是否共享锁等)做不同的实现
protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } 然后，不能获取锁会将当前线程封装成为一个等待节点, 并加入到CLH队列</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/ rel=bookmark>并发编程框架 AbstractQueuedSynchronizer 条件变量</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-25T21:39:16+08:00>November 25, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">wait 去竞争锁 将当前线程加入条件队列 释放当前状态变量 state 个 等待其被转移至竞争队列CLH 等待获取锁, 获取状态变量state个 /** * Implements interruptible condition wait. * &lt;ol> * &lt;li> If current thread is interrupted, throw InterruptedException. * &lt;li> Save lock state returned by {@link #getState}. * &lt;li> Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &lt;li> Block until signalled or interrupted. 在被通知或者中断之前阻塞当前线程 * &lt;li> Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-countdown/ rel=bookmark>并发编程框架 CountDown</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-25T21:38:02+08:00>November 25, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 4982264981922014374L; Sync(int count) { setState(count); } int getCount() { return getState(); } protected int tryAcquireShared(int acquires) { // 知道当前剩余可获取信号量为0的时候 才能获取到共享锁; return (getState() == 0) ? 1 : -1; } protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { // 拿状态 int c = getState(); // 如果为0 则已经释放过了, 这次直接释放失败, 保证只释放一次 if (c == 0) return false; // 设置下一次释放后锁的数量; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } } } 用户调用countdown函数, 底层是释放共享锁</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-cyclicbarrier/ rel=bookmark>并发编程框架 CyclicBarrier</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-25T21:37:30+08:00>November 25, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">数据结构 /** * 锁屏障 * The lock for guarding barrier entry */ private final ReentrantLock lock = new ReentrantLock(); /** * 条件变量 * Condition to wait on until tripped */ private final Condition trip = lock.newCondition(); /** 参与方数量 The number of parties */ private final int parties; /* 各参与方都到位后的触发命令 The command to run when tripped */ private final Runnable barrierCommand; /** 当前代 The current generation */ private Generation generation = new Generation(); /** * 当前代未到位的参与方数量 * Number of parties still waiting.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-semaphore/ rel=bookmark>并发编程框架 Semaphore</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-25T21:36:55+08:00>November 25, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">同步器Sync实现 将AQS中的state变量, 映射到Sempaphore的permit变量; 使用for(;;) + case的形式写获取和释放信号量的逻辑 /** * Synchronization implementation for semaphore. Uses AQS state * to represent permits. Subclassed into fair and nonfair * versions. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 1192457210091910933L; // 1. 将AQS中的state变量, 映射到Sempaphore的permit变量; // 许可数存放在state字段里面; Sync(int permits) { setState(permits); } // 在将state翻译成permits final int getPermits() { return getState(); } // 2. 使用for(;;) + case的形式写获取和释放信号量的逻辑 /* 非公平获取锁 */ final int nonfairTryAcquireShared(int acquires) { for (;;) { // 确实没有剩下多少 int available = getState(); int remaining = available - acquires; // 尝试修改剩余许可证数量 if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; } } protected final boolean tryReleaseShared(int releases) { for (;;) { int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error("Maximum permit count exceeded"); if (compareAndSetState(current, next)) return true; } } final void reducePermits(int reductions) { for (;;) { int current = getState(); int next = current - reductions; if (next > current) // underflow throw new Error("Permit count underflow"); if (compareAndSetState(current, next)) return; } } final int drainPermits() { for (;;) { int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; } } } 非公平 /** * NonFair version */ static final class NonfairSync extends Sync { private static final long serialVersionUID = -2694183684443567898L; /** * 利用Sync中的同步变量 初始化permits数 */ NonfairSync(int permits) { super(permits); } /** * 尝试获取许可证 */ protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); } } 公平同步器 公平同步器, 通过状态的修改必然依赖于队列中是否有已等待的节点; 来保证新线程, 不会和队列中的线程进行抢占来实现;</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantlock/ rel=bookmark>并发编程框架 ReentrantLock</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-25T21:36:05+08:00>November 25, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">同步器 /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; /** * 锁定操作 * * Performs {@link Lock#lock}. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * 1.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantreadwritelock/ rel=bookmark>并发编程框架 ReentrantReadWriteLock</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-25T21:35:01+08:00>November 25, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">构造 读写锁都是对 ReentrantReadWriteLock 中的同步器sync的封装，会共享其中的state变量
/** * Creates a new {@code ReentrantReadWriteLock} with * default (nonfair) ordering properties. */ public ReentrantReadWriteLock() { this(false); } /** * Creates a new {@code ReentrantReadWriteLock} with * the given fairness policy. * * @param fair {@code true} if this lock should use a fair ordering policy */ public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } public ReentrantReadWriteLock.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-futuretask/ rel=bookmark>并发编程框架 FutureTask</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-25T21:30:47+08:00>November 25, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">Future模式 Future代表异步执行结果. 用户可以
调用get方法获取执行结果 调用cancel方法取消执行 调用get(long, TimeUnit) 支持超时的获取结果; 内存一致性保证: 异步计算 happen-before 另外一个线程的Future.get
RunnableFuture实现 用于定义一种Future, 同时也是一个Runnable. 一旦改Runnable运行完成, 那么该Future就能得到结果;
/** * A {@link Future} that is {@link Runnable}. Successful execution of * the {@code run} method causes completion of the {@code Future} * and allows access to its results. * @see FutureTask * @see Executor * @since 1.6 * @author Doug Lea * @param &lt;V> The result type returned by this Future's {@code get} method */ public interface RunnableFuture&lt;V> extends Runnable, Future&lt;V> { /** * Sets this Future to the result of its computation * unless it has been cancelled.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bconcurrentskiplistmap/ rel=bookmark>集合之ConcurrentSkipListMap</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-11-02T00:53:30+08:00>November 02, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">结构图 总图 下面对几个接口重点说明:
SortedMap: 提供排序器查询、区间视图、头尾访问等 ConcurrentMap:
不支持null值; 所以重写了Map接口中相关默认实现为不实现 提供线程安全和原子保证; 所以重写了Map接口中相关默认实现 ConcurrentNavigableMap
重写了NavigableMap接口方法的返回类型为ConcurrentNavigableMap 源码解析 数据结构 查询 新增 删除 区间查询 迭代器 查询 注意两种情况下找不到节点:
当前节点为null, 不可能匹配key; 前缀节点为header节点, 则没有找到前缀, key太大了, 不可能匹配key /** * Gets value for key. Almost the same as findNode, but returns * the found value (to avoid retries during re-reads) * * @param key the key * @return the value, or null if absent */ private V doGet(Object key) { if (key == null) throw new NullPointerException(); Comparator&lt;?</div></article></main><div class=pagination><span class="pagination__item pagination__item--current">1/2</span>
<a class="pagination__item pagination__item--next btn" href=/halley/page/2/>»</a></div></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH... name=q aria-label=SEARCH...></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://halley-eng.github.io/halley/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-executorcompletionservice/>并发编程框架 ExecutorCompletionService</a></li><li class=widget__item><a class=widget__link href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E7%8B%AC%E5%8D%A0%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81/>并发编程框架 AbstractQueuedSynchronizer 独占和共享锁</a></li><li class=widget__item><a class=widget__link href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/>并发编程框架 AbstractQueuedSynchronizer 条件变量</a></li><li class=widget__item><a class=widget__link href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-countdown/>并发编程框架 CountDown</a></li><li class=widget__item><a class=widget__link href=/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-cyclicbarrier/>并发编程框架 CyclicBarrier</a></li></ul></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2020 月亮惹的祸.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/halley/js/menu.js></script></body></html>