<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>月亮</title><link>https://halley-eng.github.io/halley/</link><description>Recent content on 月亮</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Wed, 25 Nov 2020 22:49:02 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/index.xml" rel="self" type="application/rss+xml"/><item><title>分治题目篇</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E9%A2%98%E7%9B%AE%E7%AF%87/</link><pubDate>Wed, 25 Nov 2020 22:49:02 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E9%A2%98%E7%9B%AE%E7%AF%87/</guid><description>本文包含基于分治思想解决的《连续数列的最大和》和《23. Merge k Sorted Lists》
首先看下第一道题目:
连续数列的最大和 题目 给定一个整数数组，找出总和最大的连续数列，并返回总和。
示例：
输入： [-2,1,-3,4,-1,2,1,-5,4] 输出： 6 解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶：
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
题解 方法一: 基于 Kadane 算法解决
int maxSubArray(int[] nums) { int maxHere = 0, maxSoFar = Integer.MIN_VALUE; for (int num : nums) { // 包含当前元素的最大连续区间 maxHere = Math.max(maxHere + num, num); // 目前为止的最大连续区间; maxSoFar = Math.max(maxHere, maxSoFar); } return maxSoFar; } 方法二: 分治
首先分治法解题思路如下:
分解：将原问题分解成一系列子问题； 数组[left,right]最大和, 按中点mid切分 可以得到三个子问题</description></item><item><title>扑克牌问题</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 25 Nov 2020 21:48:23 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/</guid><description>有一堆扑克牌，将牌堆第一张放到桌子上，再将接下来的牌堆的第一张放到牌底，如此往复；
最后桌子上的牌顺序为： (牌底) 1,2,3,4,5,6,7,8,9,10,11,12,13 (牌顶)；
问：原来那堆牌的顺序，用函数实现。
题解 @Test public void paiXu() { int[] arr = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; int[] res = reverse(arr); System.out.println(Arrays.toString(res)); } private int[] reverse(int[] arr) { int len = arr.length; int[] res = new int[len]; int lastSize = len; int fromIndex = 0; while (fromIndex &amp;lt; len) { boolean isOdd = lastSize % 2 == 1; // 每次取出来一半 int useSize = lastSize / 2 + (isOdd ?</description></item><item><title>并发编程框架 ExecutorCompletionService</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-executorcompletionservice/</link><pubDate>Wed, 25 Nov 2020 21:44:15 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-executorcompletionservice/</guid><description>提交任务 public Future&amp;lt;V&amp;gt; submit(Callable&amp;lt;V&amp;gt; task) { if (task == null) throw new NullPointerException(); // 创建任务; RunnableFuture&amp;lt;V&amp;gt; f = newTaskFor(task); // 封装任务并将其提交到执行器; executor.execute(new QueueingFuture(f)); return f; } 封装任务是为了在任务执行完毕后能够接收任务完成信号
/** * FutureTask extension to enqueue upon completion */ private class QueueingFuture extends FutureTask&amp;lt;Void&amp;gt; { QueueingFuture(RunnableFuture&amp;lt;V&amp;gt; task) { super(task, null); this.task = task; } // 任务完成后 将任务添加到完成队列; protected void done() { completionQueue.add(task); } private final Future&amp;lt;V&amp;gt; task; } 完成任务的获取 任务的获取主要是封装了queue的api 支持三种模式</description></item><item><title>并发编程框架 AbstractQueuedSynchronizer 独占和共享锁</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E7%8B%AC%E5%8D%A0%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81/</link><pubDate>Wed, 25 Nov 2020 21:39:51 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E7%8B%AC%E5%8D%A0%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81/</guid><description>独占锁加锁(不响应超时和中断) 通过互斥量state获取锁: 尝试使用CAS更改状态,
如果能够获取成功, 则直接获取锁, 退出; 获取失败, 进入等待队列 addWaiter(Node.EXCLUSIVE) acquireQueued public final void acquire(int arg) { /** * {@link ReentrantLock.NonfairSync#tryAcquire(int)} 非公平方式获取锁 * * 1. 先尝试(使用CAS)获独占锁; * 2. 没有获得独占锁, 将自己作为一个独占节点并加入等待队列, * 之后在 acquireQueued 中进入不断等待的时期; * */ if (!tryAcquire(arg) &amp;amp;&amp;amp; // 先尝试获取独占锁, 如果没有申请到锁 才往下走 // 1. 将当前线程加入到同步队列,并且其占用模式为独占形式 // 2. 当前线程wait并等待自己的节点的状态 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 获取锁 获取锁的函数如下, 其需要子类，根据场景不同(是否公平锁、是否共享锁等)做不同的实现
protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } 然后，不能获取锁会将当前线程封装成为一个等待节点, 并加入到CLH队列</description></item><item><title>并发编程框架 AbstractQueuedSynchronizer 条件变量</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Wed, 25 Nov 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>wait 去竞争锁 将当前线程加入条件队列 释放当前状态变量 state 个 等待其被转移至竞争队列CLH 等待获取锁, 获取状态变量state个 /** * Implements interruptible condition wait. * &amp;lt;ol&amp;gt; * &amp;lt;li&amp;gt; If current thread is interrupted, throw InterruptedException. * &amp;lt;li&amp;gt; Save lock state returned by {@link #getState}. * &amp;lt;li&amp;gt; Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &amp;lt;li&amp;gt; Block until signalled or interrupted. 在被通知或者中断之前阻塞当前线程 * &amp;lt;li&amp;gt; Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument.</description></item><item><title>并发编程框架 CountDown</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-countdown/</link><pubDate>Wed, 25 Nov 2020 21:38:02 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-countdown/</guid><description>private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 4982264981922014374L; Sync(int count) { setState(count); } int getCount() { return getState(); } protected int tryAcquireShared(int acquires) { // 知道当前剩余可获取信号量为0的时候 才能获取到共享锁; return (getState() == 0) ? 1 : -1; } protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { // 拿状态 int c = getState(); // 如果为0 则已经释放过了, 这次直接释放失败, 保证只释放一次 if (c == 0) return false; // 设置下一次释放后锁的数量; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } } } 用户调用countdown函数, 底层是释放共享锁</description></item><item><title>并发编程框架 CyclicBarrier</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-cyclicbarrier/</link><pubDate>Wed, 25 Nov 2020 21:37:30 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-cyclicbarrier/</guid><description>数据结构 /** * 锁屏障 * The lock for guarding barrier entry */ private final ReentrantLock lock = new ReentrantLock(); /** * 条件变量 * Condition to wait on until tripped */ private final Condition trip = lock.newCondition(); /** 参与方数量 The number of parties */ private final int parties; /* 各参与方都到位后的触发命令 The command to run when tripped */ private final Runnable barrierCommand; /** 当前代 The current generation */ private Generation generation = new Generation(); /** * 当前代未到位的参与方数量 * Number of parties still waiting.</description></item><item><title>并发编程框架 Semaphore</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-semaphore/</link><pubDate>Wed, 25 Nov 2020 21:36:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-semaphore/</guid><description>同步器Sync实现 将AQS中的state变量, 映射到Sempaphore的permit变量; 使用for(;;) + case的形式写获取和释放信号量的逻辑 /** * Synchronization implementation for semaphore. Uses AQS state * to represent permits. Subclassed into fair and nonfair * versions. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 1192457210091910933L; // 1. 将AQS中的state变量, 映射到Sempaphore的permit变量; // 许可数存放在state字段里面; Sync(int permits) { setState(permits); } // 在将state翻译成permits final int getPermits() { return getState(); } // 2. 使用for(;;) + case的形式写获取和释放信号量的逻辑 /* 非公平获取锁 */ final int nonfairTryAcquireShared(int acquires) { for (;;) { // 确实没有剩下多少 int available = getState(); int remaining = available - acquires; // 尝试修改剩余许可证数量 if (remaining &amp;lt; 0 || compareAndSetState(available, remaining)) return remaining; } } protected final boolean tryReleaseShared(int releases) { for (;;) { int current = getState(); int next = current + releases; if (next &amp;lt; current) // overflow throw new Error(&amp;#34;Maximum permit count exceeded&amp;#34;); if (compareAndSetState(current, next)) return true; } } final void reducePermits(int reductions) { for (;;) { int current = getState(); int next = current - reductions; if (next &amp;gt; current) // underflow throw new Error(&amp;#34;Permit count underflow&amp;#34;); if (compareAndSetState(current, next)) return; } } final int drainPermits() { for (;;) { int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; } } } 非公平 /** * NonFair version */ static final class NonfairSync extends Sync { private static final long serialVersionUID = -2694183684443567898L; /** * 利用Sync中的同步变量 初始化permits数 */ NonfairSync(int permits) { super(permits); } /** * 尝试获取许可证 */ protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); } } 公平同步器 公平同步器, 通过状态的修改必然依赖于队列中是否有已等待的节点; 来保证新线程, 不会和队列中的线程进行抢占来实现;</description></item><item><title>并发编程框架 ReentrantLock</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantlock/</link><pubDate>Wed, 25 Nov 2020 21:36:05 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantlock/</guid><description>同步器 /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; /** * 锁定操作 * * Performs {@link Lock#lock}. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * 1.</description></item><item><title>并发编程框架 ReentrantReadWriteLock</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantreadwritelock/</link><pubDate>Wed, 25 Nov 2020 21:35:01 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantreadwritelock/</guid><description>构造 读写锁都是对 ReentrantReadWriteLock 中的同步器sync的封装，会共享其中的state变量
/** * Creates a new {@code ReentrantReadWriteLock} with * default (nonfair) ordering properties. */ public ReentrantReadWriteLock() { this(false); } /** * Creates a new {@code ReentrantReadWriteLock} with * the given fairness policy. * * @param fair {@code true} if this lock should use a fair ordering policy */ public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } public ReentrantReadWriteLock.</description></item><item><title>并发编程框架 FutureTask</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-futuretask/</link><pubDate>Wed, 25 Nov 2020 21:30:47 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-futuretask/</guid><description>Future模式 Future代表异步执行结果. 用户可以
调用get方法获取执行结果 调用cancel方法取消执行 调用get(long, TimeUnit) 支持超时的获取结果; 内存一致性保证: 异步计算 happen-before 另外一个线程的Future.get
RunnableFuture实现 用于定义一种Future, 同时也是一个Runnable. 一旦改Runnable运行完成, 那么该Future就能得到结果;
/** * A {@link Future} that is {@link Runnable}. Successful execution of * the {@code run} method causes completion of the {@code Future} * and allows access to its results. * @see FutureTask * @see Executor * @since 1.6 * @author Doug Lea * @param &amp;lt;V&amp;gt; The result type returned by this Future&amp;#39;s {@code get} method */ public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; { /** * Sets this Future to the result of its computation * unless it has been cancelled.</description></item><item><title>根据数字二进制下1的数目排序_1356</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F_1356/</link><pubDate>Sat, 07 Nov 2020 00:14:23 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F_1356/</guid><description>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。
如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。
请你返回排序后的数组。
示例 1：
输入：arr = [0,1,2,3,4,5,6,7,8] 输出：[0,1,2,4,8,3,5,6,7] 解释：[0] 是唯一一个有 0 个 1 的数。 [1,2,4,8] 都有 1 个 1 。 [3,5,6] 有 2 个 1 。 [7] 有 3 个 1 。 按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 示例 2：
输入：arr = [1024,512,256,128,64,32,16,8,4,2,1] 输出：[1,2,4,8,16,32,64,128,256,512,1024] 解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。 示例 3：
输入：arr = [10000,10000] 输出：[10000,10000] 示例 4：
输入：arr = [2,3,5,7,11,13,17,19] 输出：[2,3,5,17,7,11,13,19] 示例 5：
输入：arr = [10,100,1000,10000] 输出：[10,100,10000,1000] 提示：</description></item><item><title>集合之ConcurrentSkipListMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bconcurrentskiplistmap/</link><pubDate>Mon, 02 Nov 2020 00:53:30 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bconcurrentskiplistmap/</guid><description>结构图 总图 下面对几个接口重点说明:
SortedMap: 提供排序器查询、区间视图、头尾访问等 ConcurrentMap:
不支持null值; 所以重写了Map接口中相关默认实现为不实现 提供线程安全和原子保证; 所以重写了Map接口中相关默认实现 ConcurrentNavigableMap
重写了NavigableMap接口方法的返回类型为ConcurrentNavigableMap 源码解析 数据结构 查询 新增 删除 区间查询 迭代器 查询 注意两种情况下找不到节点:
当前节点为null, 不可能匹配key; 前缀节点为header节点, 则没有找到前缀, key太大了, 不可能匹配key /** * Gets value for key. Almost the same as findNode, but returns * the found value (to avoid retries during re-reads) * * @param key the key * @return the value, or null if absent */ private V doGet(Object key) { if (key == null) throw new NullPointerException(); Comparator&amp;lt;?</description></item><item><title>单词拆分ii_140</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86ii_140/</link><pubDate>Sun, 01 Nov 2020 21:09:30 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86ii_140/</guid><description>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。
说明：
分隔时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。
示例 1：
输入: s = &amp;ldquo;catsanddog&amp;rdquo; wordDict = [&amp;ldquo;cat&amp;rdquo;, &amp;ldquo;cats&amp;rdquo;, &amp;ldquo;and&amp;rdquo;, &amp;ldquo;sand&amp;rdquo;, &amp;ldquo;dog&amp;rdquo;] 输出: [ &amp;ldquo;cats and dog&amp;rdquo;, &amp;ldquo;cat sand dog&amp;rdquo; ]
示例 2：
输入: s = &amp;ldquo;pineapplepenapple&amp;rdquo; wordDict = [&amp;ldquo;apple&amp;rdquo;, &amp;ldquo;pen&amp;rdquo;, &amp;ldquo;applepen&amp;rdquo;, &amp;ldquo;pine&amp;rdquo;, &amp;ldquo;pineapple&amp;rdquo;] 输出: [ &amp;ldquo;pine apple pen apple&amp;rdquo;, &amp;ldquo;pineapple pen apple&amp;rdquo;, &amp;ldquo;pine applepen apple&amp;rdquo; ] 解释: 注意你可以重复使用字典中的单词。 示例 3：
输入: s = &amp;ldquo;catsandog&amp;rdquo; wordDict = [&amp;ldquo;cats&amp;rdquo;, &amp;ldquo;dog&amp;rdquo;, &amp;ldquo;sand&amp;rdquo;, &amp;ldquo;and&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;] 输出: []</description></item><item><title>集合之HashSet</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashset/</link><pubDate>Sat, 31 Oct 2020 14:58:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashset/</guid><description>插入 以参数e为key, value固定为常量 PRESENT 插入到map.
通过map的key的唯一性保证集合的唯一性; 因为底层是HashMap, 所以并不能保证有序; public boolean add(E e) { return m.put(e, PRESENT)==null; } 删除 如果字典能成功删除对象o, 并且其值为PRESENT时.
public boolean remove(Object o) { return m.remove(o)==PRESENT; } 异常处理 因为TreeSet需要依赖key的有序性来处理问题, 所以会产生下面的异常:
ClassCastException: 当输入的key不能与字段中存量的key比较时; NullPointerException: 当输入的key为null, 并且比较器不兼容null值时，或者没有比较器时;
但是HashSet并不需要有序性保证，而且key支持null, 所以甚至没有npe异常;
其他 利用key在底层字典中只保证唯一性 不保证有序性, 所以TreeSet没有提供导航接口。</description></item><item><title>集合之TreeSet</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreeset/</link><pubDate>Sat, 31 Oct 2020 14:35:59 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreeset/</guid><description>核心点分解 插入 以参数e为key, value固定为常量 PRESENT 插入到map.
通过map的key的唯一性保证集合的唯一性. 通过map的有序性保证集合的有序性. public boolean add(E e) { return m.put(e, PRESENT)==null; } 删除 如果字典能成功删除对象o, 并且其值为PRESENT时.
public boolean remove(Object o) { return m.remove(o)==PRESENT; } 异常处理 ClassCastException: 当输入的key不能与字段中存量的key比较时;
NullPointerException: 当输入的key为null, 并且比较器不兼容null值时，或者没有比较器时;
其他 利用key在底层字典中的有序性, 所以TreeSet也能提供相关导航接口.</description></item><item><title>岛屿数量_463</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F_463/</link><pubDate>Sat, 31 Oct 2020 00:04:11 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F_463/</guid><description>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
 示例 :
输入: [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]
输出: 16
解释: 它的周长是下面图片中的 16 个黄色的边：
题解 迭代法: 反向思考 class Solution { public int islandPerimeter(int[][] grid) { //重点关注前面遍历过得方格，如果之前有相邻方格，就-2; if (grid == null || grid.length == 0) { return 0; } int rsp = 0; for (int i = 0; i &amp;lt; grid.length; i++) { for (int j = 0; j &amp;lt; grid[i].</description></item><item><title>集合之TreeMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreemap/</link><pubDate>Fri, 30 Oct 2020 22:16:46 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreemap/</guid><description>核心点分解 插入过程 删除过程 导航方法 lowerEntry floorEntry ceilingEntry higherEntry 视图 headMap subMap tailMap 迭代器 查询 firstKey lastKey 插入 两种情况下返回null
根节点root == null 遍历整颗树后依然没有发现已存在的节点 空指针异常:
当key为null, 且没有指定comparator， 使用key对象的compareTo(T t); 存在排序器 comparator 但是其不支持; ClassCastException:
当没有制定排序器时，会提取Key值的 Compareble接口, 如果不能cast到则会抛出对应的ClassCastException public V put(K key, V value) { // 本地化根节点 root 到 t; Entry&amp;lt;K,V&amp;gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check // 初始化root节点; root = new Entry&amp;lt;&amp;gt;(key, value, null); size = 1; modCount++; // 返回旧节点为null; return null; } int cmp; Entry&amp;lt;K,V&amp;gt; parent; // split comparator and comparable paths Comparator&amp;lt;?</description></item><item><title>集合之LinkedHashMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedhashmap/</link><pubDate>Tue, 27 Oct 2020 21:53:21 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedhashmap/</guid><description>核心点分解 数据结构 构造方法 链表特殊操作 查询 迭代器 视图 数据结构 // 链表头指针 transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head; // 链表尾指针 transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail; // 是否维持访问序 final boolean accessOrder; 构造方法 在HashMap的所有构造方法上, 都加上了 accessOrder 属性
/** * Constructs an empty insertion-ordered &amp;lt;tt&amp;gt;LinkedHashMap&amp;lt;/tt&amp;gt; instance * with the specified initial capacity and a default load factor (0.75). * * @param initialCapacity the initial capacity * @throws IllegalArgumentException if the initial capacity is negative */ public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } /** * Constructs an empty insertion-ordered &amp;lt;tt&amp;gt;LinkedHashMap&amp;lt;/tt&amp;gt; instance * with the default initial capacity (16) and load factor (0.</description></item><item><title>集合之HashMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</link><pubDate>Mon, 26 Oct 2020 00:28:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</guid><description>[TOC]
关键知识点分解 数据结构 构造方法 插入过程 hash定位算法; 红黑树插入 链表插入 链表插入触发树化过程; 删除过程 迭代器 LinkedHashMap 钩子函数 uml 数据结构 核心属性如下:
transient Node&amp;lt;K,V&amp;gt;[] table; transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet; transient int size; transient int modCount; int threshold; final float loadFactor; 4个构造方法 容量 + 负载因子构造
initialCapacity : 检测有效性及赋值; loadFactor : 检测有效性及赋值; 设置初始阈值为 最小满足的2次方数; public HashMap(int initialCapacity, float loadFactor) { // 检测容量有效性; 太小则报错; if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&amp;#34;Illegal initial capacity: &amp;#34; + initialCapacity); // 太大则取最大值; if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 检测负载因子的有效性; if (loadFactor &amp;lt;= 0 || Float.</description></item><item><title>长按键入 925</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5-925/</link><pubDate>Wed, 21 Oct 2020 21:30:49 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5-925/</guid><description>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。
你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。
示例 1：
输入：name = &amp;ldquo;alex&amp;rdquo;, typed = &amp;ldquo;aaleex&amp;rdquo; 输出：true 解释：&amp;lsquo;alex&amp;rsquo; 中的 &amp;lsquo;a&amp;rsquo; 和 &amp;lsquo;e&amp;rsquo; 被长按。 示例 2：
输入：name = &amp;ldquo;saeed&amp;rdquo;, typed = &amp;ldquo;ssaaedd&amp;rdquo; 输出：false 解释：&amp;lsquo;e&amp;rsquo; 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3：
输入：name = &amp;ldquo;leelee&amp;rdquo;, typed = &amp;ldquo;lleeelee&amp;rdquo; 输出：true 示例 4：
输入：name = &amp;ldquo;laiden&amp;rdquo;, typed = &amp;ldquo;laiden&amp;rdquo; 输出：true 解释：长按名字中的字符并不是必要的。 提示：
name.length &amp;lt;= 1000 typed.length &amp;lt;= 1000 name 和 typed 的字符都是小写字母。 题解 双指针 - 迭代typed, 匹配name 循环子过程 迭代typed, 每个字符有三种情况:</description></item><item><title>重排链表 143</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-143/</link><pubDate>Wed, 21 Oct 2020 00:00:38 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-143/</guid><description>给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1:
给定链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 重新排列为 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. 示例 2:
给定链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 重新排列为 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3.
题解 链表中点 + 反转链表 + 合并链表 注意反转链表前要把拆分成两个链表;
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public void reorderList(ListNode head) { if(head == null) return; // 1.</description></item><item><title>比较含退格的字符串 844</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-844/</link><pubDate>Mon, 19 Oct 2020 23:55:25 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-844/</guid><description>比较含退格的字符串 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
 示例 1：
输入：S = &amp;ldquo;ab#c&amp;rdquo;, T = &amp;ldquo;ad#c&amp;rdquo; 输出：true 解释：S 和 T 都会变成 “ac”。 示例 2：
输入：S = &amp;ldquo;ab##&amp;rdquo;, T = &amp;ldquo;c#d#&amp;rdquo; 输出：true 解释：S 和 T 都会变成 “”。 示例 3：
输入：S = &amp;ldquo;a##c&amp;rdquo;, T = &amp;ldquo;#a#c&amp;rdquo; 输出：true 解释：S 和 T 都会变成 “c”。 示例 4：
输入：S = &amp;ldquo;a#c&amp;rdquo;, T = &amp;ldquo;b&amp;rdquo; 输出：false 解释：S 会变成 “c”，但 T 仍然是 “b”。 提示：
1 &amp;lt;= S.</description></item><item><title>删除链表的倒数第N个节点 19</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-19/</link><pubDate>Sun, 18 Oct 2020 10:06:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-19/</guid><description>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
示例：
给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5. 说明：
给定的 n 保证是有效的。
进阶：
你能尝试使用一趟扫描实现吗？
题解 一次扫描法: 定义并初始化快慢指针和dummy节点; 初始化循环子过程 快指针初始化走n步, 使得如果链表长度为n, 满足 slow.next 就是要删除的节点; 保持: 快慢指针各走1步, 链表长度增长,依然满足 slow.next 就是要删除的节点; 删除 slow.next 节点; 返回链表头部; /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.</description></item><item><title>N 八皇后ii 52</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/n-%E5%85%AB%E7%9A%87%E5%90%8Eii-52/</link><pubDate>Sun, 18 Oct 2020 00:34:46 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/n-%E5%85%AB%E7%9A%87%E5%90%8Eii-52/</guid><description>N皇后 II n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例:
输入: 4 输出: 2 解释: 4 皇后问题存在如下两个不同的解法。 [ [&amp;quot;.Q..&amp;rdquo;, // 解法 1 &amp;ldquo;&amp;hellip;Q&amp;rdquo;, &amp;ldquo;Q&amp;hellip;&amp;rdquo;, &amp;ldquo;..Q.&amp;quot;],
 [&amp;rdquo;..Q.&amp;rdquo;, // 解法 2 &amp;ldquo;Q&amp;hellip;&amp;rdquo;, &amp;ldquo;&amp;hellip;Q&amp;rdquo;, &amp;ldquo;.Q..&amp;quot;] ]
提示：
皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。（引用自 百度百科 - 皇后 ）
题解 回溯法 class Solution { int ans = 0; boolean[] pie, na, colums; public int totalNQueens(int n) { pie = new boolean[2 * n]; na = new boolean[2 * n]; colums = new boolean[n]; backtracking(0, n); return ans; } void backtracking(int row, int size){ if(row == size){ ans++; return; } // process current level for(int col = 0; col &amp;lt; size; col++){ // 前向检查可以放 int checkPie = col + row; int checkNa = col - row + size; if(colums[col] || pie[checkPie] || na[checkNa]) continue; // 则放 colums[col] = pie[checkPie] = na[checkNa] = true; // process next level backtracking(row + 1, size); // restore status colums[col] = pie[checkPie] = na[checkNa] = false; } } } 二进制解法 todo: 相关链接 leetcode leetcode discurss</description></item><item><title>有序数组的平方 977</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-977/</link><pubDate>Fri, 16 Oct 2020 08:33:25 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-977/</guid><description>给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
 示例 1：
输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2：
输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示：
1 &amp;lt;= A.length &amp;lt;= 10000 -10000 &amp;lt;= A[i] &amp;lt;= 10000 A 已按非递减顺序排序。 题解 直接排序 class Solution { public int[] sortedSquares(int[] A) { int len = A.length; for(int i = 0; i &amp;lt; len;i++){ A[i] = A[i] * A[i]; } Arrays.sort(A); return A; } } 时间复杂度: O(nlogn) 空间复杂度: O(1)
双指针 非递减顺序排序的整数数组 A 的平方特征是 两边较大, 中间较小;
class Solution { public int[] sortedSquares(int[] A) { int len = A.</description></item><item><title>填充每个节点的下一个右侧节点指针 116</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-116/</link><pubDate>Thu, 15 Oct 2020 23:12:19 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-116/</guid><description>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
 示例： 输入：{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;1&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;2&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;3&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:4},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;4&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:5},&amp;ldquo;val&amp;rdquo;:2},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;5&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;6&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:6},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;7&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:7},&amp;ldquo;val&amp;rdquo;:3},&amp;ldquo;val&amp;rdquo;:1}
输出：{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;1&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;2&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;3&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;4&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;5&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;6&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:7},&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:6},&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:5},&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:4},&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;7&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;5&amp;rdquo;},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;6&amp;rdquo;},&amp;ldquo;val&amp;rdquo;:3},&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;4&amp;rdquo;},&amp;ldquo;val&amp;rdquo;:2},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;7&amp;rdquo;},&amp;ldquo;val&amp;rdquo;:1}
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。
提示：
你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
题解 中序遍历 + HashMap class Solution { Map&amp;lt;Integer, Node&amp;gt; preNode = new HashMap&amp;lt;&amp;gt;(); public Node connect(Node root) { dfs(root, 0); return root; } void dfs(Node node, int level){ if(node == null) return; dfs(node.left, level + 1); Node pre = preNode.</description></item><item><title>查找常用字符 1002</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6-1002/</link><pubDate>Wed, 14 Oct 2020 21:22:24 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6-1002/</guid><description>查找常用字符 给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。
你可以按任意顺序返回答案。
 示例 1：
输入：[&amp;ldquo;bella&amp;rdquo;,&amp;ldquo;label&amp;rdquo;,&amp;ldquo;roller&amp;rdquo;] 输出：[&amp;ldquo;e&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;] 示例 2：
输入：[&amp;ldquo;cool&amp;rdquo;,&amp;ldquo;lock&amp;rdquo;,&amp;ldquo;cook&amp;rdquo;] 输出：[&amp;ldquo;c&amp;rdquo;,&amp;ldquo;o&amp;rdquo;] 提示：
1 &amp;lt;= A.length &amp;lt;= 100 1 &amp;lt;= A[i].length &amp;lt;= 100 A[i][j] 是小写字母
题解 class Solution { int MAX_TIME = 101; public List&amp;lt;String&amp;gt; commonChars(String[] A) { int len = A.length; // 1. 统计每个字符串中每个字符出现的次数; List&amp;lt;int[]&amp;gt; allWordFreq = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; len; i++){ String str = A[i]; int[] wordFreq = new int[26]; for(int j = 0; j &amp;lt; str.</description></item><item><title>集合之ArrayDeque</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</link><pubDate>Wed, 14 Oct 2020 01:49:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</guid><description>核心点 初始化 关键函数 头部新增 尾部新增 头尾新增对比 头部删除 尾部删除 任意位置删除 扩缩容 迭代器 DeqIterator DescendingIterator DeqSpliterator 三种初始化方法 1. 无参默认16个 public ArrayDeque() { elements = new Object[16]; } 2. 指定参数最少8个或者2的n次方个 默认最小申请8个 否则申请 &amp;gt;= 当前需要容量的 2的n次方个; 通过无符号右移 1、2、4、8、16 位分别保证 连续的 2、4、6、16、32 位都是 1 在 + 1 得到最近的 2的n次方 public ArrayDeque(int numElements) { allocateElements(numElements); } private void allocateElements(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements.</description></item><item><title>二叉搜索树的最小绝对差 530</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-530/</link><pubDate>Wed, 14 Oct 2020 00:11:22 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-530/</guid><description>二叉搜索树的最小绝对差 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例：
输入：
1 3 / 2
输出： 1
解释： 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
暴力 - 排序 如果不使用二叉树中序遍历是有序这个特性 那么使用任何一种遍历方法: 先序、中序、后序或者层序
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int getMinimumDifference(TreeNode root) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); dfs(root, list); Collections.</description></item><item><title>两两交换链表中的节点 24</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-24/</link><pubDate>Tue, 13 Oct 2020 11:44:20 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-24/</guid><description>两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例:
给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 你应该返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
题解 重复子过程
取两个节点 first,second first 指向重复子过程 second.next 指向first 返回 second 边界条件: first == null || second == null
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { return dfs(head); } ListNode dfs(ListNode head){ if(head == null || head.</description></item><item><title>集合之LinkedList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</link><pubDate>Sun, 11 Oct 2020 20:58:34 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</guid><description>核心点 链表数据结构; 链表基本操作; 迭代器 位置定位 链表数据结构; 双链表包含 prev 和 next 两个指针;
private static class Node&amp;lt;E&amp;gt; { E item; Node&amp;lt;E&amp;gt; next; Node&amp;lt;E&amp;gt; prev; Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) { this.item = element; this.next = next; this.prev = prev; } } 双链表基本操作 头部新增 缓存旧头节点: f 创建新节点并升级为头节点 first 新节点next指针指向旧的头节点 处理旧头节点: f null : 新节点同时更新到last 否则其pre节点指向新节点; /** * Links e as first element. */ private void linkFirst(E e) { final Node&amp;lt;E&amp;gt; f = first; final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.</description></item><item><title>分割等和子集 416</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-416/</link><pubDate>Sun, 11 Oct 2020 15:19:35 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-416/</guid><description>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:
每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:
输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2:
输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.
题解 思路: 将原来的问题转化为对于n个数并且其和为sum, 选择其中部分数组和为sum/2; 则可以转化为0-1背包问题
定义状态: dp[i][j]: 对于区间[0,i] 个数, 是否可以组成和为j； i : [0, n) j : [0, sum / 2]
边界条件: dp[i][0] == true 目标容量为0, 总是可以达到; i == 0 时, 仅有 dp[0][nums[0]] = true: 递推方程: dp[i][j] =</description></item><item><title>集合之ArrayList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</link><pubDate>Sat, 10 Oct 2020 18:28:19 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</guid><description>三种不同的初始化方法
扩缩容机制
null元素的特殊处理
removeIf 基于BitSet的实现;
序列化和反序列化
迭代器之内部类 ListItr,Itr
视图之内部类 SubList
底层数组修饰符transient有什么用?
ArrayListSpliterator
transient Object[] elementData;
三种不同的初始化方法 指定容量初始化 容量为0时底层数组指向空数组; 容量有效则按需申请; 负数容量抛出异常 public ArrayList(int initialCapacity) { if (initialCapacity &amp;gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&amp;#34;Illegal Capacity: &amp;#34;+ initialCapacity); } } 默认空数组初始化 public ArrayList() { this.</description></item><item><title>环形链表ii 142</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii-142/</link><pubDate>Sat, 10 Oct 2020 10:03:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii-142/</guid><description>Hash冲突检测法 重复子过程(while):
检测到冲突则返回; 标记; 移动指针; public class Solution { public ListNode detectCycle(ListNode head) { // 1. 定义访问标记数组 Set&amp;lt;ListNode&amp;gt; visited = new HashSet&amp;lt;ListNode&amp;gt;(); // 2. 迭代链表,并标记, 如果发生标记冲突事件则其发生地为首次相遇的点; while(head != null){ // 检查是否标记冲突; if(visited.contains(head)) return head; visited.add(head); head = head.next; } // 3. 不曾发生标记冲突时间, 则没有环; return null; } } 时间复杂度: O(n) 空间复杂度: O(n)
快慢指针法 public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head, slow = head; while(fast !</description></item><item><title>环形链表 141</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141/</link><pubDate>Fri, 09 Oct 2020 22:08:47 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141/</guid><description>给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
 进阶：
你能用 O(1)（即，常量）内存解决此问题吗？
题解报告 重复子过程(while)
检测快慢指针有效性 检测是否有环 移动指针; public class Solution { public boolean hasCycle(ListNode head) { // 1. 检测边界条件 if(head == null || head.next == null) return false; // 2. 初始化快慢指针; ListNode fast = head.next.next; ListNode slow = head.next; // 3. 快慢指针迭代链表; while (fast !</description></item><item><title>集合之Vector</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</link><pubDate>Thu, 08 Oct 2020 23:59:32 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</guid><description>关键点拆分如下:
扩缩容机制 迭代器实现 普通迭代器 列表迭代器 并行迭代器 视图实现 子列表视图 随机访问视图 扩容机制 在新增元素的时候, 确保容量足够
private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &amp;gt; 0) grow(minCapacity); } /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.</description></item><item><title>集合包</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</link><pubDate>Thu, 08 Oct 2020 16:22:17 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</guid><description>计划通过如下两个视角来总结相关实现;
结构视角: High Level 俯视 聚焦视角: 每个类的每个方法详细解说; 集合包结构视图 聚焦计划及进度 目前先只考虑非并发集合实现
List
Vector ArrayList LinkedList CopyOnWriteArrayList Queue
LinkedList ArrayDeque ConcurrentLinkedDeque BlockingDeque Set
LinkedHashSet TreeSet Map
IdentityHashMap&amp;lt;K,V&amp;gt; HashMap&amp;lt;K,V&amp;gt; LinkedHashMap&amp;lt;K,V&amp;gt; ConcurrentSkipListMap&amp;lt;K,V&amp;gt; TreeMap&amp;lt;K,V&amp;gt; WeakHashMap&amp;lt;K,V&amp;gt; Hashtable&amp;lt;K,V&amp;gt; Properties 共 14 篇</description></item><item><title>反转字符串 344</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/</link><pubDate>Thu, 08 Oct 2020 10:07:06 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/</guid><description>反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
示例 1：
输入：[&amp;ldquo;h&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;o&amp;rdquo;] 输出：[&amp;ldquo;o&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;h&amp;rdquo;] 示例 2：
输入：[&amp;ldquo;H&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;h&amp;rdquo;] 输出：[&amp;ldquo;h&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;H&amp;rdquo;]
题解 class Solution { public void reverseString(char[] s) { // 重复子过程: 从区间 [0, len - 1] 两端取出两个元素, 交换之, 并收敛双指针; int l = 0, r = s.length - 1; while(l &amp;lt; r) { char tmp = s[l]; s[l] = s[r]; s[r] = tmp; l++; r--; } } } 说明循环总会结束 while 循环中总会 l++, r&amp;ndash;, 总会压缩解空间, 所以一定会结束, 不会死循环;</description></item><item><title>颜色分类 75</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-75/</link><pubDate>Wed, 07 Oct 2020 10:37:33 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-75/</guid><description>75. 颜色分类 颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意: 不能使用代码库中的排序函数来解决这道题。
示例:
输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶：
一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？
双指针法 思路是: 使用两个指针left, right, 和另外一个指针 i 扫描为分类区域; 其中
left 定义最左面放置数字“0”的区间的右边界; right定义最右面放置数字“2”的区间的左边界; 循环过程中通过迭代i,将0和2交换到左右区间, 直到 i &amp;gt; right得到期望的结果。
我们先给出源码, 然后通过循环不变式证明while循环的正确性;
private static void sortColor(int[] color) { // left : 下一个0 将要放置的位置; [-oo , left) // right: 下一个2 将要放置的位置; (right, +oo] // i : 待分类的元素位置; [left, i) 存放数据 1 ( 且left &amp;lt; i有效, 否则表示为检测到1) // [i, right] 为未分类区间; // 当未分类区间为空时候终止, 即 i &amp;gt; right, 最后一个未分类元素为 i == right; int i = 0, left = 0, right = color.</description></item><item><title>关于作者</title><link>https://halley-eng.github.io/halley/about/</link><pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate><guid>https://halley-eng.github.io/halley/about/</guid><description>有计划的输出自己感兴趣的内容应该是件让人快乐的事情吧; 所有我来了;
&amp;ldquo;月亮惹的祸&amp;rdquo; 其实主要想要月亮这个词, 技术人都是想偏理性的, 写文章更是一件非常理性的事情, 但是在这个理性的地方， 如果能有一个感性的心态做粘合剂， 那么步伐一定会 更坚定。 更持久。</description></item></channel></rss>