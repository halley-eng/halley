<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>月亮惹的祸</title><link>https://halley-eng.github.io/halley/</link><description>Recent content on 月亮惹的祸</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Sat, 10 Oct 2020 18:28:19 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/index.xml" rel="self" type="application/rss+xml"/><item><title>集合之ArrayList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</link><pubDate>Sat, 10 Oct 2020 18:28:19 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</guid><description>三种不同的初始化方法
扩缩容机制
null元素的特殊处理
removeIf 基于BitSet的实现;
序列化和反序列化
迭代器之内部类 ListItr,Itr
视图之内部类 SubList
底层数组修饰符transient有什么用?
ArrayListSpliterator
transient Object[] elementData;
三种不同的初始化方法 指定容量初始化 容量为0时底层数组指向空数组; 容量有效则按需申请; 负数容量抛出异常 public ArrayList(int initialCapacity) { if (initialCapacity &amp;gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&amp;#34;Illegal Capacity: &amp;#34;+ initialCapacity); } } 默认空数组初始化 public ArrayList() { this.</description></item><item><title>环形链表ii 142</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii-142/</link><pubDate>Sat, 10 Oct 2020 10:03:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii-142/</guid><description>Hash冲突检测法 重复子过程(while):
检测到冲突则返回; 标记; 移动指针; public class Solution { public ListNode detectCycle(ListNode head) { // 1. 定义访问标记数组 Set&amp;lt;ListNode&amp;gt; visited = new HashSet&amp;lt;ListNode&amp;gt;(); // 2. 迭代链表,并标记, 如果发生标记冲突事件则其发生地为首次相遇的点; while(head != null){ // 检查是否标记冲突; if(visited.contains(head)) return head; visited.add(head); head = head.next; } // 3. 不曾发生标记冲突时间, 则没有环; return null; } } 时间复杂度: O(n) 空间复杂度: O(n)
快慢指针法 public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head, slow = head; while(fast !</description></item><item><title>环形链表 141</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141/</link><pubDate>Fri, 09 Oct 2020 22:08:47 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141/</guid><description>给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
 进阶：
你能用 O(1)（即，常量）内存解决此问题吗？
题解报告 重复子过程(while)
检测快慢指针有效性 检测是否有环 移动指针; public class Solution { public boolean hasCycle(ListNode head) { // 1. 检测边界条件 if(head == null || head.next == null) return false; // 2. 初始化快慢指针; ListNode fast = head.next.next; ListNode slow = head.next; // 3. 快慢指针迭代链表; while (fast !</description></item><item><title>集合之Vector</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</link><pubDate>Thu, 08 Oct 2020 23:59:32 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</guid><description>关键点拆分如下:
扩缩容机制 迭代器实现 普通迭代器 列表迭代器 并行迭代器 视图实现 子列表视图 随机访问视图 扩容机制 在新增元素的时候, 确保容量足够
private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &amp;gt; 0) grow(minCapacity); } /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.</description></item><item><title>集合包</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</link><pubDate>Thu, 08 Oct 2020 16:22:17 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</guid><description>计划通过如下两个视角来总结相关实现;
结构视角: High Level 俯视 聚焦视角: 每个类的每个方法详细解说; 集合包结构视图 聚焦计划及进度 目前先只考虑非并发集合实现
List
Vector ArrayList LinkedList CopyOnWriteArrayList Queue
LinkedList ArrayDeque ConcurrentLinkedDeque BlockingDeque Set
LinkedHashSet TreeSet Map
IdentityHashMap&amp;lt;K,V&amp;gt; HashMap&amp;lt;K,V&amp;gt; LinkedHashMap&amp;lt;K,V&amp;gt; ConcurrentSkipListMap&amp;lt;K,V&amp;gt; TreeMap&amp;lt;K,V&amp;gt; WeakHashMap&amp;lt;K,V&amp;gt; Hashtable&amp;lt;K,V&amp;gt; Properties 共 14 篇</description></item><item><title>反转字符串 344</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/</link><pubDate>Thu, 08 Oct 2020 10:07:06 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/</guid><description>反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
示例 1：
输入：[&amp;ldquo;h&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;o&amp;rdquo;] 输出：[&amp;ldquo;o&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;h&amp;rdquo;] 示例 2：
输入：[&amp;ldquo;H&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;h&amp;rdquo;] 输出：[&amp;ldquo;h&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;H&amp;rdquo;]
题解 class Solution { public void reverseString(char[] s) { // 重复子过程: 从区间 [0, len - 1] 两端取出两个元素, 交换之, 并收敛双指针; int l = 0, r = s.length - 1; while(l &amp;lt; r) { char tmp = s[l]; s[l] = s[r]; s[r] = tmp; l++; r--; } } } 说明循环总会结束 while 循环中总会 l++, r&amp;ndash;, 总会压缩解空间, 所以一定会结束, 不会死循环;</description></item><item><title>颜色分类 75</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-75/</link><pubDate>Wed, 07 Oct 2020 10:37:33 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-75/</guid><description>75. 颜色分类 颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意: 不能使用代码库中的排序函数来解决这道题。
示例:
输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶：
一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？
双指针法 思路是: 使用两个指针left, right, 和另外一个指针 i 扫描为分类区域; 其中
left 定义最左面放置数字“0”的区间的右边界; right定义最右面放置数字“2”的区间的左边界; 循环过程中通过迭代i,将0和2交换到左右区间, 直到 i &amp;gt; right得到期望的结果。
我们先给出源码, 然后通过循环不变式证明while循环的正确性;
private static void sortColor(int[] color) { // left : 下一个0 将要放置的位置; [-oo , left) // right: 下一个2 将要放置的位置; (right, +oo] // i : 待分类的元素位置; [left, i) 存放数据 1 ( 且left &amp;lt; i有效, 否则表示为检测到1) // [i, right] 为未分类区间; // 当未分类区间为空时候终止, 即 i &amp;gt; right, 最后一个未分类元素为 i == right; int i = 0, left = 0, right = color.</description></item><item><title>关于作者</title><link>https://halley-eng.github.io/halley/about/</link><pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate><guid>https://halley-eng.github.io/halley/about/</guid><description>有计划的输出自己感兴趣的内容应该是件让人快乐的事情吧; 所有我来了;</description></item></channel></rss>