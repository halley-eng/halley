<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>月亮</title><link>https://halley-eng.github.io/halley/</link><description>Recent content on 月亮</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Tue, 22 Dec 2020 21:39:16 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/index.xml" rel="self" type="application/rss+xml"/><item><title>Configuration注解之ConfigurationClassPostProcessor</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/configuration%E6%B3%A8%E8%A7%A3%E4%B9%8Bconfigurationclasspostprocessor/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/configuration%E6%B3%A8%E8%A7%A3%E4%B9%8Bconfigurationclasspostprocessor/</guid><description>运行时机 BeanDefinitionRegistryPostProcessor 钩子 通过实现 BeanDefinitionRegistryPostProcessor 接口, 可以在IOC容器刷新阶段的调用, 如下方法
/** * Derive further bean definitions from the configuration classes in the registry. */ @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { // 1. 保证IOC容器只能处理一次; int registryId = System.identityHashCode(registry); if (this.registriesPostProcessed.contains(registryId)) { throw new IllegalStateException( &amp;#34;postProcessBeanDefinitionRegistry already called on this post-processor against &amp;#34; + registry); } if (this.factoriesPostProcessed.contains(registryId)) { throw new IllegalStateException( &amp;#34;postProcessBeanFactory already called on this post-processor against &amp;#34; + registry); } this.</description></item><item><title>JdbcTemplate相关源码</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/jdbctemplate%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/jdbctemplate%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81/</guid><description>JdbcTemplate 相关源码 数据行映射到对象 BeanPropertyRowMapper#mapRow /** * Extract the values for all columns in the current row. * &amp;lt;p&amp;gt;Utilizes public setters and result set meta-data. * @see java.sql.ResultSetMetaData */ @Override public T mapRow(ResultSet rs, int rowNumber) throws SQLException { // 1. 构建并初始化BeanWrapper BeanWrapperImpl bw = new BeanWrapperImpl(); initBeanWrapper(bw); // 2. 构建实例; T mappedObject = constructMappedInstance(rs, bw); // 3. 封装到 Spring 的BeanWrapper bw.setBeanInstance(mappedObject); // 4. 循环解析每一列到BeanWrapper; ResultSetMetaData rsmd = rs.</description></item><item><title>mybatis源码</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E6%BA%90%E7%A0%81/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E6%BA%90%E7%A0%81/</guid><description>Mapper代理创建 org.mybatis.spring.mapper.MapperFactoryBean#getObject
@Override public T getObject() throws Exception { return getSqlSession().getMapper(this.mapperInterface); } 这里的配置通常是 SqlSessionTemplate 它是 spring-mybatis 实现的线程安全会话创建和生命周期管理类;
后期 SqlSession 的方法都会通过他的拦截器 SqlSessionTemplate.SqlSessionInterceptor 详细如下:
Sql Session 拦截器接收sql参数并执行 SqlSessionTemplate.SqlSessionInterceptor
该拦截器负责
封装 SqlSession 的获取 调用 SqlSession 的相关方法，完成sql执行的生命周期; private class SqlSessionInterceptor implements InvocationHandler { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 1. 获取会话 SqlSession sqlSession = getSqlSession( SqlSessionTemplate.this.sqlSessionFactory, // 每个工厂么每个线程都能仅能找到唯一一个 SqlSession SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try { // 2.</description></item><item><title>mybatis解析xml和动态sql</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E8%A7%A3%E6%9E%90xml%E5%92%8C%E5%8A%A8%E6%80%81sql/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E8%A7%A3%E6%9E%90xml%E5%92%8C%E5%8A%A8%E6%80%81sql/</guid><description>mybatis 如何解析xml文件 support.DaoSupport#afterPropertiesSet MapperFactoryBean#checkDaoConfig 总之， MapperFactoryBean该工厂bean初始化后就会注册到 MapperRegistry org.apache.ibatis.binding.MapperRegistry#addMapper 在触发解析xml MapperAnnotationBuilder#parse MapperAnnotationBuilder#loadXmlResource MapperBuilderAssistant#addMappedStatement
动态sql解析 DynamicSqlSource#getBoundSql
根据参数解析动态sql生成 BoundSql
public BoundSql getBoundSql(Object parameterObject) { BoundSql boundSql = sqlSource.getBoundSql(parameterObject); List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings == null || parameterMappings.isEmpty()) { boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject); } // check for nested result maps in parameter mappings (issue #30) for (ParameterMapping pm : boundSql.getParameterMappings()) { String rmId = pm.getResultMapId(); if (rmId != null) { ResultMap rm = configuration.</description></item><item><title>shardingspare源码</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/shardingspare%E6%BA%90%E7%A0%81/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/shardingspare%E6%BA%90%E7%A0%81/</guid><description>shardingsphere源码解析 使用方法 导入包
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.shardingsphere&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;shardingsphere-jdbc-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${shardingsphere.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 配置路由规则 比如两库两表
// Configure actual data sources Map&amp;lt;String, DataSource&amp;gt; dataSourceMap = new HashMap&amp;lt;&amp;gt;(); // Configure the first data source BasicDataSource dataSource1 = new BasicDataSource(); dataSource1.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource1.setUrl(&amp;#34;jdbc:mysql://localhost:3306/ds0&amp;#34;); dataSource1.setUsername(&amp;#34;root&amp;#34;); dataSource1.setPassword(&amp;#34;&amp;#34;); dataSourceMap.put(&amp;#34;ds0&amp;#34;, dataSource1); // Configure the second data source BasicDataSource dataSource2 = new BasicDataSource(); dataSource2.setDriverClassName(&amp;#34;com.mysql.jdbc.Driver&amp;#34;); dataSource2.setUrl(&amp;#34;jdbc:mysql://localhost:3306/ds1&amp;#34;); dataSource2.setUsername(&amp;#34;root&amp;#34;); dataSource2.setPassword(&amp;#34;&amp;#34;); dataSourceMap.put(&amp;#34;ds1&amp;#34;, dataSource2); // Configure order table rule ShardingTableRuleConfiguration orderTableRuleConfig = new ShardingTableRuleConfiguration(&amp;#34;t_order&amp;#34;, &amp;#34;ds${0..1}.t_order${0..1}&amp;#34;); // Configure database sharding strategy orderTableRuleConfig.</description></item><item><title>Spring-Boot启动分析</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring-boot%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring-boot%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90/</guid><description>以常见的SpringBoot 工程启动类举例
@SpringBootApplication(scanBasePackages = {&amp;#34;com.xxx.xxx.xxx&amp;#34;}) @EnableAspectJAutoProxy @EnableConfigCenter @EnableMbean @EnableScheduling public class FcXxxApplication { public static void main(String[] args) throws Exception { SpringApplication.run(FcXxxApplication.class, args); Runtime.getRuntime().addShutdownHook(new AppShutdownHook()); } } 这里简单的通过 SpringApplication#run 就可以启动Spring 容器, 并让其运行在 Web 容器中;
下面是其核心源码
public ConfigurableApplicationContext run(String... args) { // 1. 计数器初始化并启动 StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&amp;lt;SpringBootExceptionReporter&amp;gt; exceptionReporters = new ArrayList&amp;lt;&amp;gt;(); configureHeadlessProperty(); // 2. 加载并启动监听器 SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try { ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); // 3.</description></item><item><title>SpringFramework之AutowiredAnnotationBeanPostProcessor</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/springframework%E4%B9%8Bautowiredannotationbeanpostprocessor/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/springframework%E4%B9%8Bautowiredannotationbeanpostprocessor/</guid><description>支持注入的注解类型 从如下构造方法可知其支持的给两种注解类型
Autowired Value /** * Create a new AutowiredAnnotationBeanPostProcessor * for Spring&amp;#39;s standard {@link Autowired} annotation. * &amp;lt;p&amp;gt;Also supports JSR-330&amp;#39;s {@link javax.inject.Inject} annotation, if available. */ @SuppressWarnings(&amp;#34;unchecked&amp;#34;) public AutowiredAnnotationBeanPostProcessor() { this.autowiredAnnotationTypes.add(Autowired.class); this.autowiredAnnotationTypes.add(Value.class); try { this.autowiredAnnotationTypes.add((Class&amp;lt;? extends Annotation&amp;gt;) ClassUtils.forName(&amp;#34;javax.inject.Inject&amp;#34;, AutowiredAnnotationBeanPostProcessor.class.getClassLoader())); logger.trace(&amp;#34;JSR-330 &amp;#39;javax.inject.Inject&amp;#39; annotation found and supported for autowiring&amp;#34;); } catch (ClassNotFoundException ex) { // JSR-330 API not available - simply skip. } } 注入的时机 Value 注解和 Autowire 都是由 AutowiredAnnotationBeanPostProcessor 负责解析依赖并注入的 但是Value的数据源为需要手动注册 PropertySourcesPlaceholderConfigurer</description></item><item><title>Spring注解解析</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/</guid><description>Spring 解析注解 注解中的属性方法定义 AttributeMethods#isAttributeMethod
/** * 属性方法的定义是 无参数 有返回值得方法; * @param method * @return */ private static boolean isAttributeMethod(Method method) { return (method.getParameterCount() == 0 &amp;amp;&amp;amp; method.getReturnType() != void.class); } 获取注解中的所有属性方法 private static AttributeMethods compute(Class&amp;lt;? extends Annotation&amp;gt; annotationType) { // 1. 收集所有方法 Method[] methods = annotationType.getDeclaredMethods(); int size = methods.length; // 2. 过滤得到属性方法; for (int i = 0; i &amp;lt; methods.length; i++) { if (!isAttributeMethod(methods[i])) { methods[i] = null; size--; } } if (size == 0) { return NONE; } // 3.</description></item><item><title>Spring解析Configuration类</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E8%A7%A3%E6%9E%90configuration%E7%B1%BB/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E8%A7%A3%E6%9E%90configuration%E7%B1%BB/</guid><description>解析所有配置类 ConfigurationClassParser#parse(Set)
public void parse(Set&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates) { // 1. 扫描所有配置类; for (BeanDefinitionHolder holder : configCandidates) { BeanDefinition bd = holder.getBeanDefinition(); try { // 1.1 带注解的解析; if (bd instanceof AnnotatedBeanDefinition) { parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } // 1.2 else if (bd instanceof AbstractBeanDefinition &amp;amp;&amp;amp; ((AbstractBeanDefinition) bd).hasBeanClass()) { parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); } // 1.3 else { parse(bd.getBeanClassName(), holder.getBeanName()); } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &amp;#34;Failed to parse configuration class [&amp;#34; + bd.</description></item><item><title>注解EnableTransactionManagement自动导入事务管理器</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E6%B3%A8%E8%A7%A3enabletransactionmanagement%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E6%B3%A8%E8%A7%A3enabletransactionmanagement%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/</guid><description>事务注解的解析流程
ConfigurationClassPostProcessor 解析配置类 发现注解类型 EnableTransactionManagement 根据注解找到其对应的 Selector 实现 TransactionManagementConfigurationSelector 解析器调用 selector 实现父类 AdviceModeImportSelector 的 selectImports(AnnotationMetadata importingClassMetadata)方法 AdviceModeImportSelector 解析出通知模式后 调用selector实现类 的 selectImports(AdviceMode adviceMode) 第四部源码如下:
根据通知模式模式(AspectJ/Proxy)路由不同的配置类; AdviceModeImportSelector#selectImports(AnnotationMetadata)
@Override public final String[] selectImports(AnnotationMetadata importingClassMetadata) { // 1. 查询当前类作为别人的父类是, 子类给的泛型参数是什么, 它是当前类要处理的注解类型; Class&amp;lt;?&amp;gt; annoType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class); // 2. 从源配置类中查询出来, 注解参数实际对象; AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType); if (attributes == null) { throw new IllegalArgumentException(String.format( &amp;#34;@%s is not present on importing class &amp;#39;%s&amp;#39; as expected&amp;#34;, annoType.</description></item><item><title>集群命令总线 DistributedCommandBus SpringCloud扩展实现</title><link>https://halley-eng.github.io/halley/axon/%E9%9B%86%E7%BE%A4%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF-distributedcommandbus-springcloud%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 25 Nov 2020 23:36:25 +0800</pubDate><guid>https://halley-eng.github.io/halley/axon/%E9%9B%86%E7%BE%A4%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF-distributedcommandbus-springcloud%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0/</guid><description>集群命令总线用于消息在多个节点之间的转发, SpringCloud扩展实现使用一致性hash算法, 有效的将消息的压力负载到多个节点上面;
集群命令总线相对于简单命令总线多了路由器和连接器;
消息派发过程 通过路由器找到目标节点 destination; 使用连接器发送出去 找不到目标节点则抛出异常; @Override public &amp;lt;C&amp;gt; void dispatch(CommandMessage&amp;lt;C&amp;gt; command) { if (defaultCommandCallback != null) { dispatch(command, defaultCommandCallback); return; } LoggingCallback loggingCallback = LoggingCallback.INSTANCE; // 没有消息监控器 则直接派发; if (NoOpMessageMonitor.INSTANCE.equals(messageMonitor)) { // 派发拦截器 CommandMessage&amp;lt;? extends C&amp;gt; interceptedCommand = intercept(command); // 路由找节点; Optional&amp;lt;Member&amp;gt; optionalDestination = commandRouter.findDestination(interceptedCommand); if (optionalDestination.isPresent()) { Member destination = optionalDestination.get(); try { // 发送到目标节点; connector.send(destination, interceptedCommand); } catch (Exception e) { destination.</description></item><item><title>简单命令总线 SimpleCommandBus</title><link>https://halley-eng.github.io/halley/axon/%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF-simplecommandbus/</link><pubDate>Wed, 25 Nov 2020 23:35:04 +0800</pubDate><guid>https://halley-eng.github.io/halley/axon/%E7%AE%80%E5%8D%95%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BA%BF-simplecommandbus/</guid><description>架构图 构建处理器 Builder 支持配置项如下:
事务管理器: transactionManager 监控器: messageMonitor 回滚配置: rollbackConfiguration 冲突检测器: duplicateCommandHandlerResolver 默认命令处理器: defaultCommandCallback 它们的默认配置如下:
private TransactionManager transactionManager = NoTransactionManager.INSTANCE; private MessageMonitor&amp;lt;? super CommandMessage&amp;lt;?&amp;gt;&amp;gt; messageMonitor = NoOpMessageMonitor.INSTANCE; private RollbackConfiguration rollbackConfiguration = RollbackConfigurationType.UNCHECKED_EXCEPTIONS; private DuplicateCommandHandlerResolver duplicateCommandHandlerResolver = DuplicateCommandHandlerResolution.logAndOverride(); private CommandCallback&amp;lt;Object, Object&amp;gt; defaultCommandCallback = LoggingCallback.INSTANCE; 这里提供的默认处理器是什么都不做, 但是调用方就不用处理NPE问题了; 比如事务处理器
public enum NoTransactionManager implements TransactionManager { /** * Singleton instance of the TransactionManager */ INSTANCE; /** * Returns the singleton instance of this TransactionManager * * @return the singleton instance of this TransactionManager */ public static TransactionManager instance() { return INSTANCE; } @Override public Transaction startTransaction() { return TRANSACTION; } private static final Transaction TRANSACTION = new Transaction() { @Override public void commit() { //no op } @Override public void rollback() { //no op } }; } 订阅 (subscribe) 对冲突处理提供通过自定义冲突处理器，提供定制化能力。</description></item><item><title>Axon总揽</title><link>https://halley-eng.github.io/halley/axon/axon%E6%80%BB%E6%8F%BD/</link><pubDate>Wed, 25 Nov 2020 23:34:02 +0800</pubDate><guid>https://halley-eng.github.io/halley/axon/axon%E6%80%BB%E6%8F%BD/</guid><description>Messaging Concepts(消息概念) Axon 核心 概念之一是使用消息来做组件中的通信, 这样可以使得组件间位置透明, 以此做到灵活扩缩容;
所有的消息都实现Message接口, 不同的类型的消息可以做到明显区分
所有消息包含 payload、meta data 和 unique identifier 三个部分; payload: 消息体 主要是包含类型 和 对象数据组成; meta data: 描述消息体的上下文 可以用来存储tracing信息 &amp;ndash; 辅助根因分析 存储security context 注意:
所有的消息都是不可修改的(immutable), 去消息中存储数据, 意味着基于之前的消息创建一个新的消息; 这样可以保证消息在多线程和分布式环境的并发安全性; 命令(Commands) 命令用来描述更改程序状态的意图, 通常为CommandMessage接口的实现类;
命令总是有唯一的一个目标, 它不关心哪个组件处理该命令或者是该组件在哪里, 但是可能关心其输出, 所以通常命令消息通过 Command Bus 发送, 并且支持得到一个返回值;
事件(Events) 事件用来描述程序内部发生的事情, 通常的事件源为Aggregate, 在Axon中, 事件可以是所有的对象, 所以强烈建议将所有的事件都支持序列化;
当事件被派发的时候, 事件被包装成EventMessage, 实际的消息类型将会取决于事件来源
来自Aggregate: DominEventMessage 除了所有事件都有的唯一标识, 该事件还包含 类型(type) 时间戳(timestamp) sequence number: 发射源发送事件的序号; 其他: EventMessage 注意：</description></item><item><title>回溯题目</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E9%A2%98%E7%9B%AE/</link><pubDate>Wed, 25 Nov 2020 23:09:54 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E9%A2%98%E7%9B%AE/</guid><description>基于回溯思想解决的两道题目《24 Game》和《22. 括号生成》
679. 24 Game 你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。
示例 1:
输入: [4, 1, 8, 7] 输出: True 解释: (8-4) * (7-1) = 24 示例 2:
输入: [1, 2, 1, 2] 输出: False 注意:
除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。 每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。 你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</description></item><item><title>螺旋矩阵</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link><pubDate>Wed, 25 Nov 2020 23:07:32 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid><description>螺旋矩阵 题目描述
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
示例 1: 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 算法思想:
前提:
由起点坐标、方向、位移可以定义矩阵中的唯一一条线段, 并且可知当前路径下的所有坐标; 螺旋过程可以抽象为: 访问多条首位相连的线段,并且这些线段有如下特征:
起点坐标可知:</description></item><item><title>分治题目篇</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E9%A2%98%E7%9B%AE%E7%AF%87/</link><pubDate>Wed, 25 Nov 2020 22:49:02 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E9%A2%98%E7%9B%AE%E7%AF%87/</guid><description>本文包含基于分治思想解决的《连续数列的最大和》和《23. Merge k Sorted Lists》
首先看下第一道题目:
连续数列的最大和 题目 给定一个整数数组，找出总和最大的连续数列，并返回总和。
示例：
输入： [-2,1,-3,4,-1,2,1,-5,4] 输出： 6 解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶：
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
题解 方法一: 基于 Kadane 算法解决
int maxSubArray(int[] nums) { int maxHere = 0, maxSoFar = Integer.MIN_VALUE; for (int num : nums) { // 包含当前元素的最大连续区间 maxHere = Math.max(maxHere + num, num); // 目前为止的最大连续区间; maxSoFar = Math.max(maxHere, maxSoFar); } return maxSoFar; } 方法二: 分治
首先分治法解题思路如下:
分解：将原问题分解成一系列子问题； 数组[left,right]最大和, 按中点mid切分 可以得到三个子问题</description></item><item><title>扑克牌问题</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 25 Nov 2020 21:48:23 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/</guid><description>有一堆扑克牌，将牌堆第一张放到桌子上，再将接下来的牌堆的第一张放到牌底，如此往复；
最后桌子上的牌顺序为： (牌底) 1,2,3,4,5,6,7,8,9,10,11,12,13 (牌顶)；
问：原来那堆牌的顺序，用函数实现。
题解 @Test public void paiXu() { int[] arr = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; int[] res = reverse(arr); System.out.println(Arrays.toString(res)); } private int[] reverse(int[] arr) { int len = arr.length; int[] res = new int[len]; int lastSize = len; int fromIndex = 0; while (fromIndex &amp;lt; len) { boolean isOdd = lastSize % 2 == 1; // 每次取出来一半 int useSize = lastSize / 2 + (isOdd ?</description></item><item><title>并发编程框架 ExecutorCompletionService</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-executorcompletionservice/</link><pubDate>Wed, 25 Nov 2020 21:44:15 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-executorcompletionservice/</guid><description>提交任务 public Future&amp;lt;V&amp;gt; submit(Callable&amp;lt;V&amp;gt; task) { if (task == null) throw new NullPointerException(); // 创建任务; RunnableFuture&amp;lt;V&amp;gt; f = newTaskFor(task); // 封装任务并将其提交到执行器; executor.execute(new QueueingFuture(f)); return f; } 封装任务是为了在任务执行完毕后能够接收任务完成信号
/** * FutureTask extension to enqueue upon completion */ private class QueueingFuture extends FutureTask&amp;lt;Void&amp;gt; { QueueingFuture(RunnableFuture&amp;lt;V&amp;gt; task) { super(task, null); this.task = task; } // 任务完成后 将任务添加到完成队列; protected void done() { completionQueue.add(task); } private final Future&amp;lt;V&amp;gt; task; } 完成任务的获取 任务的获取主要是封装了queue的api 支持三种模式</description></item><item><title>并发编程框架 AbstractQueuedSynchronizer 独占和共享锁</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E7%8B%AC%E5%8D%A0%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81/</link><pubDate>Wed, 25 Nov 2020 21:39:51 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E7%8B%AC%E5%8D%A0%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81/</guid><description>独占锁加锁(不响应超时和中断) 通过互斥量state获取锁: 尝试使用CAS更改状态,
如果能够获取成功, 则直接获取锁, 退出; 获取失败, 进入等待队列 addWaiter(Node.EXCLUSIVE) acquireQueued public final void acquire(int arg) { /** * {@link ReentrantLock.NonfairSync#tryAcquire(int)} 非公平方式获取锁 * * 1. 先尝试(使用CAS)获独占锁; * 2. 没有获得独占锁, 将自己作为一个独占节点并加入等待队列, * 之后在 acquireQueued 中进入不断等待的时期; * */ if (!tryAcquire(arg) &amp;amp;&amp;amp; // 先尝试获取独占锁, 如果没有申请到锁 才往下走 // 1. 将当前线程加入到同步队列,并且其占用模式为独占形式 // 2. 当前线程wait并等待自己的节点的状态 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 获取锁 获取锁的函数如下, 其需要子类，根据场景不同(是否公平锁、是否共享锁等)做不同的实现
protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } 然后，不能获取锁会将当前线程封装成为一个等待节点, 并加入到CLH队列</description></item><item><title>并发编程框架 AbstractQueuedSynchronizer 条件变量</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Wed, 25 Nov 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>wait 去竞争锁 将当前线程加入条件队列 释放当前状态变量 state 个 等待其被转移至竞争队列CLH 等待获取锁, 获取状态变量state个 /** * Implements interruptible condition wait. * &amp;lt;ol&amp;gt; * &amp;lt;li&amp;gt; If current thread is interrupted, throw InterruptedException. * &amp;lt;li&amp;gt; Save lock state returned by {@link #getState}. * &amp;lt;li&amp;gt; Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &amp;lt;li&amp;gt; Block until signalled or interrupted. 在被通知或者中断之前阻塞当前线程 * &amp;lt;li&amp;gt; Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument.</description></item><item><title>并发编程框架 CountDown</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-countdownlatch/</link><pubDate>Wed, 25 Nov 2020 21:38:02 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-countdownlatch/</guid><description>CountDownLatch 仅有一个sync属性， 并且是根据AQS自定义的Sync类型
Sync 实现 private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 4982264981922014374L; Sync(int count) { setState(count); } int getCount() { return getState(); } protected int tryAcquireShared(int acquires) { // 直到剩余可获取信号量为0的时候 才能获取到共享锁; return (getState() == 0) ? 1 : -1; } protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { // 拿状态 int c = getState(); // 如果为0 则已经释放过了, 这次直接释放失败, 保证只释放一次 if (c == 0) return false; // 设置下一次释放后锁的数量; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } } } countdown 信号量到 0 级联唤醒等待者 用户调用countdown函数, 底层是释放共享锁</description></item><item><title>并发编程框架 CyclicBarrier</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-cyclicbarrier/</link><pubDate>Wed, 25 Nov 2020 21:37:30 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-cyclicbarrier/</guid><description>数据结构 /** * 锁屏障 * The lock for guarding barrier entry */ private final ReentrantLock lock = new ReentrantLock(); /** * 条件变量 * Condition to wait on until tripped */ private final Condition trip = lock.newCondition(); /** 参与方数量 The number of parties */ private final int parties; /* 各参与方都到位后的触发命令 The command to run when tripped */ private final Runnable barrierCommand; /** 当前代 The current generation */ private Generation generation = new Generation(); /** * 当前代未到位的参与方数量 * Number of parties still waiting.</description></item><item><title>并发编程框架 Semaphore</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-semaphore/</link><pubDate>Wed, 25 Nov 2020 21:36:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-semaphore/</guid><description>同步器Sync实现 将AQS中的state变量, 映射到Sempaphore的permit变量; 使用for(;;) + case的形式写获取和释放信号量的逻辑 /** * Synchronization implementation for semaphore. Uses AQS state * to represent permits. Subclassed into fair and nonfair * versions. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 1192457210091910933L; // 1. 将AQS中的state变量, 映射到Sempaphore的permit变量; // 许可数存放在state字段里面; Sync(int permits) { setState(permits); } // 在将state翻译成permits final int getPermits() { return getState(); } // 2. 使用for(;;) + case的形式写获取和释放信号量的逻辑 /* 非公平获取锁 */ final int nonfairTryAcquireShared(int acquires) { for (;;) { // 确实没有剩下多少 int available = getState(); int remaining = available - acquires; // 尝试修改剩余许可证数量 if (remaining &amp;lt; 0 || compareAndSetState(available, remaining)) return remaining; } } protected final boolean tryReleaseShared(int releases) { for (;;) { int current = getState(); int next = current + releases; if (next &amp;lt; current) // overflow throw new Error(&amp;#34;Maximum permit count exceeded&amp;#34;); if (compareAndSetState(current, next)) return true; } } final void reducePermits(int reductions) { for (;;) { int current = getState(); int next = current - reductions; if (next &amp;gt; current) // underflow throw new Error(&amp;#34;Permit count underflow&amp;#34;); if (compareAndSetState(current, next)) return; } } final int drainPermits() { for (;;) { int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; } } } 非公平 /** * NonFair version */ static final class NonfairSync extends Sync { private static final long serialVersionUID = -2694183684443567898L; /** * 利用Sync中的同步变量 初始化permits数 */ NonfairSync(int permits) { super(permits); } /** * 尝试获取许可证 */ protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); } } 公平同步器 公平同步器, 通过状态的修改必然依赖于队列中是否有已等待的节点; 来保证新线程, 不会和队列中的线程进行抢占来实现;</description></item><item><title>并发编程框架 ReentrantLock</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantlock/</link><pubDate>Wed, 25 Nov 2020 21:36:05 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantlock/</guid><description>同步器 /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; /** * 锁定操作 * * Performs {@link Lock#lock}. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * 1.</description></item><item><title>并发编程框架 ReentrantReadWriteLock</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantreadwritelock/</link><pubDate>Wed, 25 Nov 2020 21:35:01 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantreadwritelock/</guid><description>构造 读写锁都是对 ReentrantReadWriteLock 中的同步器sync的封装，会共享其中的state变量
/** * Creates a new {@code ReentrantReadWriteLock} with * default (nonfair) ordering properties. */ public ReentrantReadWriteLock() { this(false); } /** * Creates a new {@code ReentrantReadWriteLock} with * the given fairness policy. * * @param fair {@code true} if this lock should use a fair ordering policy */ public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } public ReentrantReadWriteLock.</description></item><item><title>并发编程框架 FutureTask</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-futuretask/</link><pubDate>Wed, 25 Nov 2020 21:30:47 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-futuretask/</guid><description>Future模式 Future代表异步执行结果. 用户可以
调用get方法获取执行结果 调用cancel方法取消执行 调用get(long, TimeUnit) 支持超时的获取结果; 内存一致性保证: 异步计算 happen-before 另外一个线程的Future.get
RunnableFuture实现 用于定义一种Future, 同时也是一个Runnable. 一旦该Runnable运行完成, 那么该Future就能得到结果;
/** * A {@link Future} that is {@link Runnable}. Successful execution of * the {@code run} method causes completion of the {@code Future} * and allows access to its results. * @see FutureTask * @see Executor * @since 1.6 * @author Doug Lea * @param &amp;lt;V&amp;gt; The result type returned by this Future&amp;#39;s {@code get} method */ public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; { /** * Sets this Future to the result of its computation * unless it has been cancelled.</description></item><item><title>根据数字二进制下1的数目排序_1356</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F_1356/</link><pubDate>Sat, 07 Nov 2020 00:14:23 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F_1356/</guid><description>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。
如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。
请你返回排序后的数组。
示例 1：
输入：arr = [0,1,2,3,4,5,6,7,8] 输出：[0,1,2,4,8,3,5,6,7] 解释：[0] 是唯一一个有 0 个 1 的数。 [1,2,4,8] 都有 1 个 1 。 [3,5,6] 有 2 个 1 。 [7] 有 3 个 1 。 按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 示例 2：
输入：arr = [1024,512,256,128,64,32,16,8,4,2,1] 输出：[1,2,4,8,16,32,64,128,256,512,1024] 解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。 示例 3：
输入：arr = [10000,10000] 输出：[10000,10000] 示例 4：
输入：arr = [2,3,5,7,11,13,17,19] 输出：[2,3,5,17,7,11,13,19] 示例 5：
输入：arr = [10,100,1000,10000] 输出：[10,100,10000,1000] 提示：</description></item><item><title>集合之ConcurrentSkipListMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bconcurrentskiplistmap/</link><pubDate>Mon, 02 Nov 2020 00:53:30 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bconcurrentskiplistmap/</guid><description>结构图 总图 下面对几个接口重点说明:
SortedMap: 提供排序器查询、区间视图、头尾访问等 ConcurrentMap:
不支持null值; 所以重写了Map接口中相关默认实现为不实现 提供线程安全和原子保证; 所以重写了Map接口中相关默认实现 ConcurrentNavigableMap
重写了NavigableMap接口方法的返回类型为ConcurrentNavigableMap 源码解析 数据结构 查询 新增 删除 区间查询 迭代器 查询 注意两种情况下找不到节点:
当前节点为null, 不可能匹配key; 前缀节点为header节点, 则没有找到前缀, key太大了, 不可能匹配key /** * Gets value for key. Almost the same as findNode, but returns * the found value (to avoid retries during re-reads) * * @param key the key * @return the value, or null if absent */ private V doGet(Object key) { if (key == null) throw new NullPointerException(); Comparator&amp;lt;?</description></item><item><title>单词拆分ii_140</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86ii_140/</link><pubDate>Sun, 01 Nov 2020 21:09:30 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86ii_140/</guid><description>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。
说明：
分隔时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。
示例 1：
输入: s = &amp;ldquo;catsanddog&amp;rdquo; wordDict = [&amp;ldquo;cat&amp;rdquo;, &amp;ldquo;cats&amp;rdquo;, &amp;ldquo;and&amp;rdquo;, &amp;ldquo;sand&amp;rdquo;, &amp;ldquo;dog&amp;rdquo;] 输出: [ &amp;ldquo;cats and dog&amp;rdquo;, &amp;ldquo;cat sand dog&amp;rdquo; ]
示例 2：
输入: s = &amp;ldquo;pineapplepenapple&amp;rdquo; wordDict = [&amp;ldquo;apple&amp;rdquo;, &amp;ldquo;pen&amp;rdquo;, &amp;ldquo;applepen&amp;rdquo;, &amp;ldquo;pine&amp;rdquo;, &amp;ldquo;pineapple&amp;rdquo;] 输出: [ &amp;ldquo;pine apple pen apple&amp;rdquo;, &amp;ldquo;pineapple pen apple&amp;rdquo;, &amp;ldquo;pine applepen apple&amp;rdquo; ] 解释: 注意你可以重复使用字典中的单词。 示例 3：
输入: s = &amp;ldquo;catsandog&amp;rdquo; wordDict = [&amp;ldquo;cats&amp;rdquo;, &amp;ldquo;dog&amp;rdquo;, &amp;ldquo;sand&amp;rdquo;, &amp;ldquo;and&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;] 输出: []</description></item><item><title>集合之HashSet</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashset/</link><pubDate>Sat, 31 Oct 2020 14:58:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashset/</guid><description>插入 以参数e为key, value固定为常量 PRESENT 插入到map.
通过map的key的唯一性保证集合的唯一性; 因为底层是HashMap, 所以并不能保证有序; public boolean add(E e) { return m.put(e, PRESENT)==null; } 删除 如果字典能成功删除对象o, 并且其值为PRESENT时.
public boolean remove(Object o) { return m.remove(o)==PRESENT; } 异常处理 因为TreeSet需要依赖key的有序性来处理问题, 所以会产生下面的异常:
ClassCastException: 当输入的key不能与字段中存量的key比较时; NullPointerException: 当输入的key为null, 并且比较器不兼容null值时，或者没有比较器时;
但是HashSet并不需要有序性保证，而且key支持null, 所以甚至没有npe异常;
其他 利用key在底层字典中只保证唯一性 不保证有序性, 所以TreeSet没有提供导航接口。</description></item><item><title>集合之TreeSet</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreeset/</link><pubDate>Sat, 31 Oct 2020 14:35:59 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreeset/</guid><description>核心点分解 插入 以参数e为key, value固定为常量 PRESENT 插入到map.
通过map的key的唯一性保证集合的唯一性. 通过map的有序性保证集合的有序性. public boolean add(E e) { return m.put(e, PRESENT)==null; } 删除 如果字典能成功删除对象o, 并且其值为PRESENT时.
public boolean remove(Object o) { return m.remove(o)==PRESENT; } 异常处理 ClassCastException: 当输入的key不能与字段中存量的key比较时;
NullPointerException: 当输入的key为null, 并且比较器不兼容null值时，或者没有比较器时;
其他 利用key在底层字典中的有序性, 所以TreeSet也能提供相关导航接口.</description></item><item><title>岛屿数量_463</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F_463/</link><pubDate>Sat, 31 Oct 2020 00:04:11 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F_463/</guid><description>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
 示例 :
输入: [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]
输出: 16
解释: 它的周长是下面图片中的 16 个黄色的边：
题解 迭代法: 反向思考 class Solution { public int islandPerimeter(int[][] grid) { //重点关注前面遍历过得方格，如果之前有相邻方格，就-2; if (grid == null || grid.length == 0) { return 0; } int rsp = 0; for (int i = 0; i &amp;lt; grid.length; i++) { for (int j = 0; j &amp;lt; grid[i].</description></item><item><title>集合之TreeMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreemap/</link><pubDate>Fri, 30 Oct 2020 22:16:46 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreemap/</guid><description>核心点分解 插入过程 删除过程 导航方法 lowerEntry floorEntry ceilingEntry higherEntry 视图 headMap subMap tailMap 迭代器 查询 firstKey lastKey 插入 两种情况下返回null
根节点root == null 遍历整颗树后依然没有发现已存在的节点 空指针异常:
当key为null, 且没有指定comparator， 使用key对象的compareTo(T t); 存在排序器 comparator 但是其不支持; ClassCastException:
当没有制定排序器时，会提取Key值的 Compareble接口, 如果不能cast到则会抛出对应的ClassCastException public V put(K key, V value) { // 本地化根节点 root 到 t; Entry&amp;lt;K,V&amp;gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check // 初始化root节点; root = new Entry&amp;lt;&amp;gt;(key, value, null); size = 1; modCount++; // 返回旧节点为null; return null; } int cmp; Entry&amp;lt;K,V&amp;gt; parent; // split comparator and comparable paths Comparator&amp;lt;?</description></item><item><title>集合之LinkedHashMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedhashmap/</link><pubDate>Tue, 27 Oct 2020 21:53:21 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedhashmap/</guid><description>核心点分解 数据结构 构造方法 链表特殊操作 查询 迭代器 视图 数据结构 // 链表头指针 transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head; // 链表尾指针 transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail; // 是否维持访问序 final boolean accessOrder; 构造方法 在HashMap的所有构造方法上, 都加上了 accessOrder 属性
/** * Constructs an empty insertion-ordered &amp;lt;tt&amp;gt;LinkedHashMap&amp;lt;/tt&amp;gt; instance * with the specified initial capacity and a default load factor (0.75). * * @param initialCapacity the initial capacity * @throws IllegalArgumentException if the initial capacity is negative */ public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } /** * Constructs an empty insertion-ordered &amp;lt;tt&amp;gt;LinkedHashMap&amp;lt;/tt&amp;gt; instance * with the default initial capacity (16) and load factor (0.</description></item><item><title>集合之HashMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</link><pubDate>Mon, 26 Oct 2020 00:28:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</guid><description>[TOC]
关键知识点分解 数据结构 构造方法 插入过程 hash定位算法; 红黑树插入 链表插入 链表插入触发树化过程; 删除过程 迭代器 LinkedHashMap 钩子函数 uml 数据结构 核心属性如下:
transient Node&amp;lt;K,V&amp;gt;[] table; transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet; transient int size; transient int modCount; int threshold; final float loadFactor; 4个构造方法 容量 + 负载因子构造
initialCapacity : 检测有效性及赋值; loadFactor : 检测有效性及赋值; 设置初始阈值为 最小满足的2次方数; public HashMap(int initialCapacity, float loadFactor) { // 检测容量有效性; 太小则报错; if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&amp;#34;Illegal initial capacity: &amp;#34; + initialCapacity); // 太大则取最大值; if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 检测负载因子的有效性; if (loadFactor &amp;lt;= 0 || Float.</description></item><item><title>颜色分类 75</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-75/</link><pubDate>Sun, 25 Oct 2020 23:37:33 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-75/</guid><description>75. 颜色分类 颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意: 不能使用代码库中的排序函数来解决这道题。
示例:
输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶：
一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？
双指针法 思路是: 使用两个指针left, right, 和另外一个指针 i 扫描为分类区域; 其中
left 定义最左面放置数字“0”的区间的右边界; right定义最右面放置数字“2”的区间的左边界; 循环过程中通过迭代i,将0和2交换到左右区间, 直到 i &amp;gt; right得到期望的结果。
我们先给出源码, 然后通过循环不变式证明while循环的正确性;
private static void sortColor(int[] color) { // left : 下一个0 将要放置的位置; [-oo , left) // right: 下一个2 将要放置的位置; (right, +oo] // i : 待分类的元素位置; [left, i) 存放数据 1 ( 且left &amp;lt; i有效, 否则表示为检测到1) // [i, right] 为未分类区间; // 当未分类区间为空时候终止, 即 i &amp;gt; right, 最后一个未分类元素为 i == right; int i = 0, left = 0, right = color.</description></item><item><title>长按键入 925</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5-925/</link><pubDate>Wed, 21 Oct 2020 21:30:49 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5-925/</guid><description>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。
你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。
示例 1：
输入：name = &amp;ldquo;alex&amp;rdquo;, typed = &amp;ldquo;aaleex&amp;rdquo; 输出：true 解释：&amp;lsquo;alex&amp;rsquo; 中的 &amp;lsquo;a&amp;rsquo; 和 &amp;lsquo;e&amp;rsquo; 被长按。 示例 2：
输入：name = &amp;ldquo;saeed&amp;rdquo;, typed = &amp;ldquo;ssaaedd&amp;rdquo; 输出：false 解释：&amp;lsquo;e&amp;rsquo; 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3：
输入：name = &amp;ldquo;leelee&amp;rdquo;, typed = &amp;ldquo;lleeelee&amp;rdquo; 输出：true 示例 4：
输入：name = &amp;ldquo;laiden&amp;rdquo;, typed = &amp;ldquo;laiden&amp;rdquo; 输出：true 解释：长按名字中的字符并不是必要的。 提示：
name.length &amp;lt;= 1000 typed.length &amp;lt;= 1000 name 和 typed 的字符都是小写字母。 题解 双指针 - 迭代typed, 匹配name 循环子过程 迭代typed, 每个字符有三种情况:</description></item><item><title>重排链表 143</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-143/</link><pubDate>Wed, 21 Oct 2020 00:00:38 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-143/</guid><description>给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1:
给定链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 重新排列为 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. 示例 2:
给定链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 重新排列为 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3.
题解 链表中点 + 反转链表 + 合并链表 注意反转链表前要把拆分成两个链表;
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public void reorderList(ListNode head) { if(head == null) return; // 1.</description></item><item><title>比较含退格的字符串 844</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-844/</link><pubDate>Mon, 19 Oct 2020 23:55:25 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-844/</guid><description>比较含退格的字符串 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
 示例 1：
输入：S = &amp;ldquo;ab#c&amp;rdquo;, T = &amp;ldquo;ad#c&amp;rdquo; 输出：true 解释：S 和 T 都会变成 “ac”。 示例 2：
输入：S = &amp;ldquo;ab##&amp;rdquo;, T = &amp;ldquo;c#d#&amp;rdquo; 输出：true 解释：S 和 T 都会变成 “”。 示例 3：
输入：S = &amp;ldquo;a##c&amp;rdquo;, T = &amp;ldquo;#a#c&amp;rdquo; 输出：true 解释：S 和 T 都会变成 “c”。 示例 4：
输入：S = &amp;ldquo;a#c&amp;rdquo;, T = &amp;ldquo;b&amp;rdquo; 输出：false 解释：S 会变成 “c”，但 T 仍然是 “b”。 提示：
1 &amp;lt;= S.</description></item><item><title>删除链表的倒数第N个节点 19</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-19/</link><pubDate>Sun, 18 Oct 2020 10:06:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-19/</guid><description>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
示例：
给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5. 说明：
给定的 n 保证是有效的。
进阶：
你能尝试使用一趟扫描实现吗？
题解 一次扫描法: 定义并初始化快慢指针和dummy节点; 初始化循环子过程 快指针初始化走n步, 使得如果链表长度为n, 满足 slow.next 就是要删除的节点; 保持: 快慢指针各走1步, 链表长度增长,依然满足 slow.next 就是要删除的节点; 删除 slow.next 节点; 返回链表头部; /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.</description></item><item><title>N 八皇后ii 52</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/n-%E5%85%AB%E7%9A%87%E5%90%8Eii-52/</link><pubDate>Sun, 18 Oct 2020 00:34:46 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/n-%E5%85%AB%E7%9A%87%E5%90%8Eii-52/</guid><description>N皇后 II n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例:
输入: 4 输出: 2 解释: 4 皇后问题存在如下两个不同的解法。 [ [&amp;quot;.Q..&amp;rdquo;, // 解法 1 &amp;ldquo;&amp;hellip;Q&amp;rdquo;, &amp;ldquo;Q&amp;hellip;&amp;rdquo;, &amp;ldquo;..Q.&amp;quot;],
 [&amp;rdquo;..Q.&amp;rdquo;, // 解法 2 &amp;ldquo;Q&amp;hellip;&amp;rdquo;, &amp;ldquo;&amp;hellip;Q&amp;rdquo;, &amp;ldquo;.Q..&amp;quot;] ]
提示：
皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。（引用自 百度百科 - 皇后 ）
题解 回溯法 class Solution { int ans = 0; boolean[] pie, na, colums; public int totalNQueens(int n) { pie = new boolean[2 * n]; na = new boolean[2 * n]; colums = new boolean[n]; backtracking(0, n); return ans; } void backtracking(int row, int size){ if(row == size){ ans++; return; } // process current level for(int col = 0; col &amp;lt; size; col++){ // 前向检查可以放 int checkPie = col + row; int checkNa = col - row + size; if(colums[col] || pie[checkPie] || na[checkNa]) continue; // 则放 colums[col] = pie[checkPie] = na[checkNa] = true; // process next level backtracking(row + 1, size); // restore status colums[col] = pie[checkPie] = na[checkNa] = false; } } } 二进制解法 todo: 相关链接 leetcode leetcode discurss</description></item><item><title>有序数组的平方 977</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-977/</link><pubDate>Fri, 16 Oct 2020 08:33:25 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-977/</guid><description>给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
 示例 1：
输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2：
输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示：
1 &amp;lt;= A.length &amp;lt;= 10000 -10000 &amp;lt;= A[i] &amp;lt;= 10000 A 已按非递减顺序排序。 题解 直接排序 class Solution { public int[] sortedSquares(int[] A) { int len = A.length; for(int i = 0; i &amp;lt; len;i++){ A[i] = A[i] * A[i]; } Arrays.sort(A); return A; } } 时间复杂度: O(nlogn) 空间复杂度: O(1)
双指针 非递减顺序排序的整数数组 A 的平方特征是 两边较大, 中间较小;
class Solution { public int[] sortedSquares(int[] A) { int len = A.</description></item><item><title>填充每个节点的下一个右侧节点指针 116</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-116/</link><pubDate>Thu, 15 Oct 2020 23:12:19 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-116/</guid><description>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
 示例： 输入：{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;1&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;2&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;3&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:4},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;4&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:5},&amp;ldquo;val&amp;rdquo;:2},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;5&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;6&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:6},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;7&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:7},&amp;ldquo;val&amp;rdquo;:3},&amp;ldquo;val&amp;rdquo;:1}
输出：{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;1&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;2&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;3&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;4&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;5&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;6&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:7},&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:6},&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:5},&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:4},&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;7&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;5&amp;rdquo;},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;6&amp;rdquo;},&amp;ldquo;val&amp;rdquo;:3},&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;4&amp;rdquo;},&amp;ldquo;val&amp;rdquo;:2},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;7&amp;rdquo;},&amp;ldquo;val&amp;rdquo;:1}
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。
提示：
你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
题解 中序遍历 + HashMap class Solution { Map&amp;lt;Integer, Node&amp;gt; preNode = new HashMap&amp;lt;&amp;gt;(); public Node connect(Node root) { dfs(root, 0); return root; } void dfs(Node node, int level){ if(node == null) return; dfs(node.left, level + 1); Node pre = preNode.</description></item><item><title>查找常用字符 1002</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6-1002/</link><pubDate>Wed, 14 Oct 2020 21:22:24 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6-1002/</guid><description>查找常用字符 给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。
你可以按任意顺序返回答案。
 示例 1：
输入：[&amp;ldquo;bella&amp;rdquo;,&amp;ldquo;label&amp;rdquo;,&amp;ldquo;roller&amp;rdquo;] 输出：[&amp;ldquo;e&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;] 示例 2：
输入：[&amp;ldquo;cool&amp;rdquo;,&amp;ldquo;lock&amp;rdquo;,&amp;ldquo;cook&amp;rdquo;] 输出：[&amp;ldquo;c&amp;rdquo;,&amp;ldquo;o&amp;rdquo;] 提示：
1 &amp;lt;= A.length &amp;lt;= 100 1 &amp;lt;= A[i].length &amp;lt;= 100 A[i][j] 是小写字母
题解 class Solution { int MAX_TIME = 101; public List&amp;lt;String&amp;gt; commonChars(String[] A) { int len = A.length; // 1. 统计每个字符串中每个字符出现的次数; List&amp;lt;int[]&amp;gt; allWordFreq = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; len; i++){ String str = A[i]; int[] wordFreq = new int[26]; for(int j = 0; j &amp;lt; str.</description></item><item><title>集合之ArrayDeque</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</link><pubDate>Wed, 14 Oct 2020 01:49:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</guid><description>核心点 初始化 关键函数 头部新增 尾部新增 头尾新增对比 头部删除 尾部删除 任意位置删除 扩缩容 迭代器 DeqIterator DescendingIterator DeqSpliterator 三种初始化方法 1. 无参默认16个 public ArrayDeque() { elements = new Object[16]; } 2. 指定参数最少8个或者2的n次方个 默认最小申请8个 否则申请 &amp;gt;= 当前需要容量的 2的n次方个; 通过无符号右移 1、2、4、8、16 位分别保证 连续的 2、4、6、16、32 位都是 1 在 + 1 得到最近的 2的n次方 public ArrayDeque(int numElements) { allocateElements(numElements); } private void allocateElements(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements.</description></item><item><title>二叉搜索树的最小绝对差 530</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-530/</link><pubDate>Wed, 14 Oct 2020 00:11:22 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-530/</guid><description>二叉搜索树的最小绝对差 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例：
输入：
1 3 / 2
输出： 1
解释： 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
暴力 - 排序 如果不使用二叉树中序遍历是有序这个特性 那么使用任何一种遍历方法: 先序、中序、后序或者层序
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int getMinimumDifference(TreeNode root) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); dfs(root, list); Collections.</description></item><item><title>两两交换链表中的节点 24</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-24/</link><pubDate>Tue, 13 Oct 2020 11:44:20 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-24/</guid><description>两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例:
给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 你应该返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
题解 重复子过程
取两个节点 first,second first 指向重复子过程 second.next 指向first 返回 second 边界条件: first == null || second == null
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { return dfs(head); } ListNode dfs(ListNode head){ if(head == null || head.</description></item><item><title>集合之LinkedList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</link><pubDate>Sun, 11 Oct 2020 20:58:34 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</guid><description>核心点 链表数据结构; 链表基本操作; 迭代器 位置定位 链表数据结构; 双链表包含 prev 和 next 两个指针;
private static class Node&amp;lt;E&amp;gt; { E item; Node&amp;lt;E&amp;gt; next; Node&amp;lt;E&amp;gt; prev; Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) { this.item = element; this.next = next; this.prev = prev; } } 双链表基本操作 头部新增 缓存旧头节点: f 创建新节点并升级为头节点 first 新节点next指针指向旧的头节点 处理旧头节点: f null : 新节点同时更新到last 否则其pre节点指向新节点; /** * Links e as first element. */ private void linkFirst(E e) { final Node&amp;lt;E&amp;gt; f = first; final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.</description></item><item><title>分割等和子集 416</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-416/</link><pubDate>Sun, 11 Oct 2020 15:19:35 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-416/</guid><description>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:
每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:
输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2:
输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.
题解 思路: 将原来的问题转化为对于n个数并且其和为sum, 选择其中部分数组和为sum/2; 则可以转化为0-1背包问题
定义状态: dp[i][j]: 对于区间[0,i] 个数, 是否可以组成和为j； i : [0, n) j : [0, sum / 2]
边界条件: dp[i][0] == true 目标容量为0, 总是可以达到; i == 0 时, 仅有 dp[0][nums[0]] = true: 递推方程: dp[i][j] =</description></item><item><title>集合之ArrayList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</link><pubDate>Sat, 10 Oct 2020 18:28:19 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</guid><description>三种不同的初始化方法
扩缩容机制
null元素的特殊处理
removeIf 基于BitSet的实现;
序列化和反序列化
迭代器之内部类 ListItr,Itr
视图之内部类 SubList
底层数组修饰符transient有什么用?
ArrayListSpliterator
transient Object[] elementData;
三种不同的初始化方法 指定容量初始化 容量为0时底层数组指向空数组; 容量有效则按需申请; 负数容量抛出异常 public ArrayList(int initialCapacity) { if (initialCapacity &amp;gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&amp;#34;Illegal Capacity: &amp;#34;+ initialCapacity); } } 默认空数组初始化 public ArrayList() { this.</description></item><item><title>环形链表ii 142</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii-142/</link><pubDate>Sat, 10 Oct 2020 10:03:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii-142/</guid><description>Hash冲突检测法 重复子过程(while):
检测到冲突则返回; 标记; 移动指针; public class Solution { public ListNode detectCycle(ListNode head) { // 1. 定义访问标记数组 Set&amp;lt;ListNode&amp;gt; visited = new HashSet&amp;lt;ListNode&amp;gt;(); // 2. 迭代链表,并标记, 如果发生标记冲突事件则其发生地为首次相遇的点; while(head != null){ // 检查是否标记冲突; if(visited.contains(head)) return head; visited.add(head); head = head.next; } // 3. 不曾发生标记冲突时间, 则没有环; return null; } } 时间复杂度: O(n) 空间复杂度: O(n)
快慢指针法 public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head, slow = head; while(fast !</description></item><item><title>环形链表 141</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141/</link><pubDate>Fri, 09 Oct 2020 22:08:47 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141/</guid><description>给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
 进阶：
你能用 O(1)（即，常量）内存解决此问题吗？
题解报告 重复子过程(while)
检测快慢指针有效性 检测是否有环 移动指针; public class Solution { public boolean hasCycle(ListNode head) { // 1. 检测边界条件 if(head == null || head.next == null) return false; // 2. 初始化快慢指针; ListNode fast = head.next.next; ListNode slow = head.next; // 3. 快慢指针迭代链表; while (fast !</description></item><item><title>集合之Vector</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</link><pubDate>Thu, 08 Oct 2020 23:59:32 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</guid><description>关键点拆分如下:
扩缩容机制 迭代器实现 普通迭代器 列表迭代器 并行迭代器 视图实现 子列表视图 随机访问视图 扩容机制 在新增元素的时候, 确保容量足够
private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &amp;gt; 0) grow(minCapacity); } /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.</description></item><item><title>集合包</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</link><pubDate>Thu, 08 Oct 2020 16:22:17 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</guid><description>计划通过如下两个视角来总结相关实现;
结构视角: High Level 俯视 聚焦视角: 每个类的每个方法详细解说; 集合包结构视图 聚焦计划及进度 目前先只考虑非并发集合实现
List
Vector ArrayList LinkedList CopyOnWriteArrayList Queue
LinkedList ArrayDeque ConcurrentLinkedDeque BlockingDeque Set
LinkedHashSet TreeSet Map
IdentityHashMap&amp;lt;K,V&amp;gt; HashMap&amp;lt;K,V&amp;gt; LinkedHashMap&amp;lt;K,V&amp;gt; ConcurrentSkipListMap&amp;lt;K,V&amp;gt; TreeMap&amp;lt;K,V&amp;gt; WeakHashMap&amp;lt;K,V&amp;gt; Hashtable&amp;lt;K,V&amp;gt; Properties 共 14 篇</description></item><item><title>反转字符串 344</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/</link><pubDate>Thu, 08 Oct 2020 10:07:06 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/</guid><description>反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
示例 1：
输入：[&amp;ldquo;h&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;o&amp;rdquo;] 输出：[&amp;ldquo;o&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;h&amp;rdquo;] 示例 2：
输入：[&amp;ldquo;H&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;h&amp;rdquo;] 输出：[&amp;ldquo;h&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;H&amp;rdquo;]
题解 class Solution { public void reverseString(char[] s) { // 重复子过程: 从区间 [0, len - 1] 两端取出两个元素, 交换之, 并收敛双指针; int l = 0, r = s.length - 1; while(l &amp;lt; r) { char tmp = s[l]; s[l] = s[r]; s[r] = tmp; l++; r--; } } } 说明循环总会结束 while 循环中总会 l++, r&amp;ndash;, 总会压缩解空间, 所以一定会结束, 不会死循环;</description></item><item><title>关于作者</title><link>https://halley-eng.github.io/halley/about/</link><pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate><guid>https://halley-eng.github.io/halley/about/</guid><description>每天进步一点点。</description></item><item><title/><link>https://halley-eng.github.io/halley/jdk/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8Bcompletablefuture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8Bcompletablefuture/</guid><description>Future 接口介绍 JDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。
阻塞的方式显然和我们的异步编程的初衷相违背， 轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果， 为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。
有一些开源框架实现了我们的设想，例如 Netty 的 ChannelFuture 类扩展了 Future 接口，通过提供 addListener 方法实现支持回调方式的异步编程。Netty 中所有的 I/O 操作都是异步的,这意味着任何的 I/O 调用都将立即返回，而不保证这些被请求的 I/O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I/O 操作结果或者状态的信息。当一个 I/O 操作开始的时候，一个新的 Future 对象就会被创建。在开始的时候，新的 Future 是未完成的状态－－它既非成功、失败，也非被取消，因为 I/O 操作还没有结束。如果 I/O 操作以成功、失败或者被取消中的任何一种状态结束了，那么这个 Future 将会被标记为已完成，并包含更多详细的信息（例如：失败的原因）。请注意，即使是失败和被取消的状态，也是属于已完成的状态。
下面主要介绍下CompletableFuture的实现和相关源码解析;
同步执行动作 示例 static void thenApplyExample() { CompletableFuture&amp;lt;String&amp;gt; cf = CompletableFuture.completedFuture(&amp;#34;message&amp;#34;).thenApply(s -&amp;gt; { assertFalse(Thread.currentThread().isDaemon()); returns.toUpperCase(); }); assertEquals(&amp;#34;MESSAGE&amp;#34;, cf.getNow(null)); } 以上代码在计算正常完成的前提下将执行动作（此处为转换成大写字母）。
相关源码 接收任务API</description></item></channel></rss>