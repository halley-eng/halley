<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>题解报告 on 月亮</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/</link><description>Recent content in 题解报告 on 月亮</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Wed, 07 Oct 2020 10:37:33 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>回溯题目</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E9%A2%98%E7%9B%AE/</link><pubDate>Wed, 25 Nov 2020 23:09:54 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E9%A2%98%E7%9B%AE/</guid><description>基于回溯思想解决的两道题目《24 Game》和《22. 括号生成》
679. 24 Game 你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。
示例 1:
输入: [4, 1, 8, 7] 输出: True 解释: (8-4) * (7-1) = 24 示例 2:
输入: [1, 2, 1, 2] 输出: False 注意:
除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。 每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。 你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。</description></item><item><title>螺旋矩阵</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link><pubDate>Wed, 25 Nov 2020 23:07:32 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid><description>螺旋矩阵 题目描述
给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
示例 1: 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 算法思想:
前提:
由起点坐标、方向、位移可以定义矩阵中的唯一一条线段, 并且可知当前路径下的所有坐标; 螺旋过程可以抽象为: 访问多条首位相连的线段,并且这些线段有如下特征:
起点坐标可知:</description></item><item><title>分治题目篇</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E9%A2%98%E7%9B%AE%E7%AF%87/</link><pubDate>Wed, 25 Nov 2020 22:49:02 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E9%A2%98%E7%9B%AE%E7%AF%87/</guid><description>本文包含基于分治思想解决的《连续数列的最大和》和《23. Merge k Sorted Lists》
首先看下第一道题目:
连续数列的最大和 题目 给定一个整数数组，找出总和最大的连续数列，并返回总和。
示例：
输入： [-2,1,-3,4,-1,2,1,-5,4] 输出： 6 解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶：
如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。
题解 方法一: 基于 Kadane 算法解决
int maxSubArray(int[] nums) { int maxHere = 0, maxSoFar = Integer.MIN_VALUE; for (int num : nums) { // 包含当前元素的最大连续区间 maxHere = Math.max(maxHere + num, num); // 目前为止的最大连续区间; maxSoFar = Math.max(maxHere, maxSoFar); } return maxSoFar; } 方法二: 分治
首先分治法解题思路如下:
分解：将原问题分解成一系列子问题； 数组[left,right]最大和, 按中点mid切分 可以得到三个子问题</description></item><item><title>扑克牌问题</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 25 Nov 2020 21:48:23 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/</guid><description>有一堆扑克牌，将牌堆第一张放到桌子上，再将接下来的牌堆的第一张放到牌底，如此往复；
最后桌子上的牌顺序为： (牌底) 1,2,3,4,5,6,7,8,9,10,11,12,13 (牌顶)；
问：原来那堆牌的顺序，用函数实现。
题解 @Test public void paiXu() { int[] arr = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; int[] res = reverse(arr); System.out.println(Arrays.toString(res)); } private int[] reverse(int[] arr) { int len = arr.length; int[] res = new int[len]; int lastSize = len; int fromIndex = 0; while (fromIndex &amp;lt; len) { boolean isOdd = lastSize % 2 == 1; // 每次取出来一半 int useSize = lastSize / 2 + (isOdd ?</description></item><item><title>根据数字二进制下1的数目排序_1356</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F_1356/</link><pubDate>Sat, 07 Nov 2020 00:14:23 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F_1356/</guid><description>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。
如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。
请你返回排序后的数组。
示例 1：
输入：arr = [0,1,2,3,4,5,6,7,8] 输出：[0,1,2,4,8,3,5,6,7] 解释：[0] 是唯一一个有 0 个 1 的数。 [1,2,4,8] 都有 1 个 1 。 [3,5,6] 有 2 个 1 。 [7] 有 3 个 1 。 按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] 示例 2：
输入：arr = [1024,512,256,128,64,32,16,8,4,2,1] 输出：[1,2,4,8,16,32,64,128,256,512,1024] 解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。 示例 3：
输入：arr = [10000,10000] 输出：[10000,10000] 示例 4：
输入：arr = [2,3,5,7,11,13,17,19] 输出：[2,3,5,17,7,11,13,19] 示例 5：
输入：arr = [10,100,1000,10000] 输出：[10,100,10000,1000] 提示：</description></item><item><title>单词拆分ii_140</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86ii_140/</link><pubDate>Sun, 01 Nov 2020 21:09:30 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86ii_140/</guid><description>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。
说明：
分隔时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。
示例 1：
输入: s = &amp;ldquo;catsanddog&amp;rdquo; wordDict = [&amp;ldquo;cat&amp;rdquo;, &amp;ldquo;cats&amp;rdquo;, &amp;ldquo;and&amp;rdquo;, &amp;ldquo;sand&amp;rdquo;, &amp;ldquo;dog&amp;rdquo;] 输出: [ &amp;ldquo;cats and dog&amp;rdquo;, &amp;ldquo;cat sand dog&amp;rdquo; ]
示例 2：
输入: s = &amp;ldquo;pineapplepenapple&amp;rdquo; wordDict = [&amp;ldquo;apple&amp;rdquo;, &amp;ldquo;pen&amp;rdquo;, &amp;ldquo;applepen&amp;rdquo;, &amp;ldquo;pine&amp;rdquo;, &amp;ldquo;pineapple&amp;rdquo;] 输出: [ &amp;ldquo;pine apple pen apple&amp;rdquo;, &amp;ldquo;pineapple pen apple&amp;rdquo;, &amp;ldquo;pine applepen apple&amp;rdquo; ] 解释: 注意你可以重复使用字典中的单词。 示例 3：
输入: s = &amp;ldquo;catsandog&amp;rdquo; wordDict = [&amp;ldquo;cats&amp;rdquo;, &amp;ldquo;dog&amp;rdquo;, &amp;ldquo;sand&amp;rdquo;, &amp;ldquo;and&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;] 输出: []</description></item><item><title>岛屿数量_463</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F_463/</link><pubDate>Sat, 31 Oct 2020 00:04:11 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F_463/</guid><description>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
 示例 :
输入: [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]]
输出: 16
解释: 它的周长是下面图片中的 16 个黄色的边：
题解 迭代法: 反向思考 class Solution { public int islandPerimeter(int[][] grid) { //重点关注前面遍历过得方格，如果之前有相邻方格，就-2; if (grid == null || grid.length == 0) { return 0; } int rsp = 0; for (int i = 0; i &amp;lt; grid.length; i++) { for (int j = 0; j &amp;lt; grid[i].</description></item><item><title>颜色分类 75</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-75/</link><pubDate>Sun, 25 Oct 2020 22:37:33 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-75/</guid><description>75. 颜色分类 颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意: 不能使用代码库中的排序函数来解决这道题。
示例:
输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶：
一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？
双指针法 思路是: 使用两个指针left, right, 和另外一个指针 i 扫描为分类区域; 其中
left 定义最左面放置数字“0”的区间的右边界; right定义最右面放置数字“2”的区间的左边界; 循环过程中通过迭代i,将0和2交换到左右区间, 直到 i &amp;gt; right得到期望的结果。
我们先给出源码, 然后通过循环不变式证明while循环的正确性;
private static void sortColor(int[] color) { // left : 下一个0 将要放置的位置; [-oo , left) // right: 下一个2 将要放置的位置; (right, +oo] // i : 待分类的元素位置; [left, i) 存放数据 1 ( 且left &amp;lt; i有效, 否则表示为检测到1) // [i, right] 为未分类区间; // 当未分类区间为空时候终止, 即 i &amp;gt; right, 最后一个未分类元素为 i == right; int i = 0, left = 0, right = color.</description></item><item><title>长按键入 925</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5-925/</link><pubDate>Wed, 21 Oct 2020 21:30:49 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5-925/</guid><description>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。
你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。
示例 1：
输入：name = &amp;ldquo;alex&amp;rdquo;, typed = &amp;ldquo;aaleex&amp;rdquo; 输出：true 解释：&amp;lsquo;alex&amp;rsquo; 中的 &amp;lsquo;a&amp;rsquo; 和 &amp;lsquo;e&amp;rsquo; 被长按。 示例 2：
输入：name = &amp;ldquo;saeed&amp;rdquo;, typed = &amp;ldquo;ssaaedd&amp;rdquo; 输出：false 解释：&amp;lsquo;e&amp;rsquo; 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3：
输入：name = &amp;ldquo;leelee&amp;rdquo;, typed = &amp;ldquo;lleeelee&amp;rdquo; 输出：true 示例 4：
输入：name = &amp;ldquo;laiden&amp;rdquo;, typed = &amp;ldquo;laiden&amp;rdquo; 输出：true 解释：长按名字中的字符并不是必要的。 提示：
name.length &amp;lt;= 1000 typed.length &amp;lt;= 1000 name 和 typed 的字符都是小写字母。 题解 双指针 - 迭代typed, 匹配name 循环子过程 迭代typed, 每个字符有三种情况:</description></item><item><title>重排链表 143</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-143/</link><pubDate>Wed, 21 Oct 2020 00:00:38 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-143/</guid><description>给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例 1:
给定链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 重新排列为 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. 示例 2:
给定链表 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 重新排列为 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3.
题解 链表中点 + 反转链表 + 合并链表 注意反转链表前要把拆分成两个链表;
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public void reorderList(ListNode head) { if(head == null) return; // 1.</description></item><item><title>比较含退格的字符串 844</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-844/</link><pubDate>Mon, 19 Oct 2020 23:55:25 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-844/</guid><description>比较含退格的字符串 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
 示例 1：
输入：S = &amp;ldquo;ab#c&amp;rdquo;, T = &amp;ldquo;ad#c&amp;rdquo; 输出：true 解释：S 和 T 都会变成 “ac”。 示例 2：
输入：S = &amp;ldquo;ab##&amp;rdquo;, T = &amp;ldquo;c#d#&amp;rdquo; 输出：true 解释：S 和 T 都会变成 “”。 示例 3：
输入：S = &amp;ldquo;a##c&amp;rdquo;, T = &amp;ldquo;#a#c&amp;rdquo; 输出：true 解释：S 和 T 都会变成 “c”。 示例 4：
输入：S = &amp;ldquo;a#c&amp;rdquo;, T = &amp;ldquo;b&amp;rdquo; 输出：false 解释：S 会变成 “c”，但 T 仍然是 “b”。 提示：
1 &amp;lt;= S.</description></item><item><title>删除链表的倒数第N个节点 19</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-19/</link><pubDate>Sun, 18 Oct 2020 10:06:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-19/</guid><description>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
示例：
给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2.
当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5. 说明：
给定的 n 保证是有效的。
进阶：
你能尝试使用一趟扫描实现吗？
题解 一次扫描法: 定义并初始化快慢指针和dummy节点; 初始化循环子过程 快指针初始化走n步, 使得如果链表长度为n, 满足 slow.next 就是要删除的节点; 保持: 快慢指针各走1步, 链表长度增长,依然满足 slow.next 就是要删除的节点; 删除 slow.next 节点; 返回链表头部; /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.</description></item><item><title>N 八皇后ii 52</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/n-%E5%85%AB%E7%9A%87%E5%90%8Eii-52/</link><pubDate>Sun, 18 Oct 2020 00:34:46 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/n-%E5%85%AB%E7%9A%87%E5%90%8Eii-52/</guid><description>N皇后 II n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。 示例:
输入: 4 输出: 2 解释: 4 皇后问题存在如下两个不同的解法。 [ [&amp;quot;.Q..&amp;rdquo;, // 解法 1 &amp;ldquo;&amp;hellip;Q&amp;rdquo;, &amp;ldquo;Q&amp;hellip;&amp;rdquo;, &amp;ldquo;..Q.&amp;quot;],
 [&amp;rdquo;..Q.&amp;rdquo;, // 解法 2 &amp;ldquo;Q&amp;hellip;&amp;rdquo;, &amp;ldquo;&amp;hellip;Q&amp;rdquo;, &amp;ldquo;.Q..&amp;quot;] ]
提示：
皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。（引用自 百度百科 - 皇后 ）
题解 回溯法 class Solution { int ans = 0; boolean[] pie, na, colums; public int totalNQueens(int n) { pie = new boolean[2 * n]; na = new boolean[2 * n]; colums = new boolean[n]; backtracking(0, n); return ans; } void backtracking(int row, int size){ if(row == size){ ans++; return; } // process current level for(int col = 0; col &amp;lt; size; col++){ // 前向检查可以放 int checkPie = col + row; int checkNa = col - row + size; if(colums[col] || pie[checkPie] || na[checkNa]) continue; // 则放 colums[col] = pie[checkPie] = na[checkNa] = true; // process next level backtracking(row + 1, size); // restore status colums[col] = pie[checkPie] = na[checkNa] = false; } } } 二进制解法 todo: 相关链接 leetcode leetcode discurss</description></item><item><title>有序数组的平方 977</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-977/</link><pubDate>Fri, 16 Oct 2020 08:33:25 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-977/</guid><description>给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。
 示例 1：
输入：[-4,-1,0,3,10] 输出：[0,1,9,16,100] 示例 2：
输入：[-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示：
1 &amp;lt;= A.length &amp;lt;= 10000 -10000 &amp;lt;= A[i] &amp;lt;= 10000 A 已按非递减顺序排序。 题解 直接排序 class Solution { public int[] sortedSquares(int[] A) { int len = A.length; for(int i = 0; i &amp;lt; len;i++){ A[i] = A[i] * A[i]; } Arrays.sort(A); return A; } } 时间复杂度: O(nlogn) 空间复杂度: O(1)
双指针 非递减顺序排序的整数数组 A 的平方特征是 两边较大, 中间较小;
class Solution { public int[] sortedSquares(int[] A) { int len = A.</description></item><item><title>填充每个节点的下一个右侧节点指针 116</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-116/</link><pubDate>Thu, 15 Oct 2020 23:12:19 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88-116/</guid><description>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
struct Node { int val; Node *left; Node *right; Node *next; } 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
 示例： 输入：{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;1&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;2&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;3&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:4},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;4&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:5},&amp;ldquo;val&amp;rdquo;:2},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;5&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;6&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:6},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;7&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:7},&amp;ldquo;val&amp;rdquo;:3},&amp;ldquo;val&amp;rdquo;:1}
输出：{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;1&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;2&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;3&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;4&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;5&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;6&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:null,&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:7},&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:6},&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:5},&amp;ldquo;right&amp;rdquo;:null,&amp;ldquo;val&amp;rdquo;:4},&amp;ldquo;next&amp;rdquo;:{&amp;ldquo;$id&amp;rdquo;:&amp;ldquo;7&amp;rdquo;,&amp;ldquo;left&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;5&amp;rdquo;},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;6&amp;rdquo;},&amp;ldquo;val&amp;rdquo;:3},&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;4&amp;rdquo;},&amp;ldquo;val&amp;rdquo;:2},&amp;ldquo;next&amp;rdquo;:null,&amp;ldquo;right&amp;rdquo;:{&amp;ldquo;$ref&amp;rdquo;:&amp;ldquo;7&amp;rdquo;},&amp;ldquo;val&amp;rdquo;:1}
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。
提示：
你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。
题解 中序遍历 + HashMap class Solution { Map&amp;lt;Integer, Node&amp;gt; preNode = new HashMap&amp;lt;&amp;gt;(); public Node connect(Node root) { dfs(root, 0); return root; } void dfs(Node node, int level){ if(node == null) return; dfs(node.left, level + 1); Node pre = preNode.</description></item><item><title>查找常用字符 1002</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6-1002/</link><pubDate>Wed, 14 Oct 2020 21:22:24 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6-1002/</guid><description>查找常用字符 给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。
你可以按任意顺序返回答案。
 示例 1：
输入：[&amp;ldquo;bella&amp;rdquo;,&amp;ldquo;label&amp;rdquo;,&amp;ldquo;roller&amp;rdquo;] 输出：[&amp;ldquo;e&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;] 示例 2：
输入：[&amp;ldquo;cool&amp;rdquo;,&amp;ldquo;lock&amp;rdquo;,&amp;ldquo;cook&amp;rdquo;] 输出：[&amp;ldquo;c&amp;rdquo;,&amp;ldquo;o&amp;rdquo;] 提示：
1 &amp;lt;= A.length &amp;lt;= 100 1 &amp;lt;= A[i].length &amp;lt;= 100 A[i][j] 是小写字母
题解 class Solution { int MAX_TIME = 101; public List&amp;lt;String&amp;gt; commonChars(String[] A) { int len = A.length; // 1. 统计每个字符串中每个字符出现的次数; List&amp;lt;int[]&amp;gt; allWordFreq = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; len; i++){ String str = A[i]; int[] wordFreq = new int[26]; for(int j = 0; j &amp;lt; str.</description></item><item><title>二叉搜索树的最小绝对差 530</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-530/</link><pubDate>Wed, 14 Oct 2020 00:11:22 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-530/</guid><description>二叉搜索树的最小绝对差 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。 示例：
输入：
1 3 / 2
输出： 1
解释： 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
暴力 - 排序 如果不使用二叉树中序遍历是有序这个特性 那么使用任何一种遍历方法: 先序、中序、后序或者层序
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int getMinimumDifference(TreeNode root) { List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;(); dfs(root, list); Collections.</description></item><item><title>两两交换链表中的节点 24</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-24/</link><pubDate>Tue, 13 Oct 2020 11:44:20 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-24/</guid><description>两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例:
给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 你应该返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.
题解 重复子过程
取两个节点 first,second first 指向重复子过程 second.next 指向first 返回 second 边界条件: first == null || second == null
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { return dfs(head); } ListNode dfs(ListNode head){ if(head == null || head.</description></item><item><title>分割等和子集 416</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-416/</link><pubDate>Sun, 11 Oct 2020 15:19:35 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-416/</guid><description>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:
每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:
输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2:
输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.
题解 思路: 将原来的问题转化为对于n个数并且其和为sum, 选择其中部分数组和为sum/2; 则可以转化为0-1背包问题
定义状态: dp[i][j]: 对于区间[0,i] 个数, 是否可以组成和为j； i : [0, n) j : [0, sum / 2]
边界条件: dp[i][0] == true 目标容量为0, 总是可以达到; i == 0 时, 仅有 dp[0][nums[0]] = true: 递推方程: dp[i][j] =</description></item><item><title>环形链表ii 142</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii-142/</link><pubDate>Sat, 10 Oct 2020 10:03:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii-142/</guid><description>Hash冲突检测法 重复子过程(while):
检测到冲突则返回; 标记; 移动指针; public class Solution { public ListNode detectCycle(ListNode head) { // 1. 定义访问标记数组 Set&amp;lt;ListNode&amp;gt; visited = new HashSet&amp;lt;ListNode&amp;gt;(); // 2. 迭代链表,并标记, 如果发生标记冲突事件则其发生地为首次相遇的点; while(head != null){ // 检查是否标记冲突; if(visited.contains(head)) return head; visited.add(head); head = head.next; } // 3. 不曾发生标记冲突时间, 则没有环; return null; } } 时间复杂度: O(n) 空间复杂度: O(n)
快慢指针法 public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head, slow = head; while(fast !</description></item><item><title>环形链表 141</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141/</link><pubDate>Fri, 09 Oct 2020 22:08:47 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141/</guid><description>给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
 进阶：
你能用 O(1)（即，常量）内存解决此问题吗？
题解报告 重复子过程(while)
检测快慢指针有效性 检测是否有环 移动指针; public class Solution { public boolean hasCycle(ListNode head) { // 1. 检测边界条件 if(head == null || head.next == null) return false; // 2. 初始化快慢指针; ListNode fast = head.next.next; ListNode slow = head.next; // 3. 快慢指针迭代链表; while (fast !</description></item><item><title>反转字符串 344</title><link>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/</link><pubDate>Thu, 08 Oct 2020 10:07:06 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/</guid><description>反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
示例 1：
输入：[&amp;ldquo;h&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;o&amp;rdquo;] 输出：[&amp;ldquo;o&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;l&amp;rdquo;,&amp;ldquo;e&amp;rdquo;,&amp;ldquo;h&amp;rdquo;] 示例 2：
输入：[&amp;ldquo;H&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;h&amp;rdquo;] 输出：[&amp;ldquo;h&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;n&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;H&amp;rdquo;]
题解 class Solution { public void reverseString(char[] s) { // 重复子过程: 从区间 [0, len - 1] 两端取出两个元素, 交换之, 并收敛双指针; int l = 0, r = s.length - 1; while(l &amp;lt; r) { char tmp = s[l]; s[l] = s[r]; s[r] = tmp; l++; r--; } } } 说明循环总会结束 while 循环中总会 l++, r&amp;ndash;, 总会压缩解空间, 所以一定会结束, 不会死循环;</description></item></channel></rss>