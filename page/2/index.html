<!doctype html><html class=no-js lang=en><head><meta name=generator content="Hugo 0.74.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>月亮惹的祸</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content="about Java、Algorithm and so on"><meta property="og:title" content="月亮惹的祸"><meta property="og:description" content="about Java、Algorithm and so on"><meta property="og:type" content="website"><meta property="og:url" content="https://halley-eng.github.io/halley/"><meta property="og:updated_time" content="2020-10-31T00:04:11+08:00"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/halley/css/style.css><link rel=alternate type=application/rss+xml href=/halley/index.xml title=月亮惹的祸><link rel="shortcut icon" href=/halley/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/halley/ title=月亮惹的祸 rel=home><div class="logo__item logo__text"><div class=logo__title>月亮惹的祸</div><div class=logo__tagline>时间过去总得留下些痕迹</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/halley/jdk/><i class="fa fa-road"></i><span class=menu__text>JDK</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/%E7%AE%97%E6%B3%95/><i class="fa fa-road"></i><span class=menu__text>算法</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/about/><span class=menu__text>关于作者</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class="main list" role=main><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E7%AE%97%E6%B3%95/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-24/ rel=bookmark>两两交换链表中的节点 24</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-13T11:44:20+08:00>October 13, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">两两交换链表中的节点 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
示例:
给定 1->2->3->4, 你应该返回 2->1->4->3.
题解 重复子过程
取两个节点 first,second first 指向重复子过程 second.next 指向first 返回 second 边界条件: first == null || second == null
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { return dfs(head); } ListNode dfs(ListNode head){ if(head == null || head.</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-416/ rel=bookmark>分割等和子集 416</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-11T15:19:35+08:00>October 11, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
注意:
每个数组中的元素不会超过 100 数组的大小不会超过 200 示例 1:
输入: [1, 5, 11, 5] 输出: true 解释: 数组可以分割成 [1, 5, 5] 和 [11]. 示例 2:
输入: [1, 2, 3, 5] 输出: false 解释: 数组不能分割成两个元素和相等的子集.
题解 思路: 将原来的问题转化为对于n个数并且其和为sum, 选择其中部分数组和为sum/2; 则可以转化为0-1背包问题
定义状态: dp[i][j]: 对于区间[0,i] 个数, 是否可以组成和为j； i : [0, n) j : [0, sum / 2]
边界条件: dp[i][0] == true 目标容量为0, 总是可以达到; i == 0 时, 仅有 dp[0][nums[0]] = true: 递推方程: dp[i][j] =</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii-142/ rel=bookmark>环形链表ii 142</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-10T10:03:37+08:00>October 10, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">Hash冲突检测法 重复子过程(while):
检测到冲突则返回; 标记; 移动指针; public class Solution { public ListNode detectCycle(ListNode head) { // 1. 定义访问标记数组 Set&lt;ListNode> visited = new HashSet&lt;ListNode>(); // 2. 迭代链表,并标记, 如果发生标记冲突事件则其发生地为首次相遇的点; while(head != null){ // 检查是否标记冲突; if(visited.contains(head)) return head; visited.add(head); head = head.next; } // 3. 不曾发生标记冲突时间, 则没有环; return null; } } 时间复杂度: O(n) 空间复杂度: O(n)
快慢指针法 public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast = head, slow = head; while(fast !</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E7%AE%97%E6%B3%95/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-141/ rel=bookmark>环形链表 141</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-09T22:08:47+08:00>October 09, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
 进阶：
你能用 O(1)（即，常量）内存解决此问题吗？
题解报告 重复子过程(while)
检测快慢指针有效性 检测是否有环 移动指针; public class Solution { public boolean hasCycle(ListNode head) { // 1. 检测边界条件 if(head == null || head.next == null) return false; // 2. 初始化快慢指针; ListNode fast = head.next.next; ListNode slow = head.next; // 3. 快慢指针迭代链表; while (fast !</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/ rel=bookmark>反转字符串 344</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-08T10:07:06+08:00>October 08, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
示例 1：
输入：[&ldquo;h&rdquo;,&ldquo;e&rdquo;,&ldquo;l&rdquo;,&ldquo;l&rdquo;,&ldquo;o&rdquo;] 输出：[&ldquo;o&rdquo;,&ldquo;l&rdquo;,&ldquo;l&rdquo;,&ldquo;e&rdquo;,&ldquo;h&rdquo;] 示例 2：
输入：[&ldquo;H&rdquo;,&ldquo;a&rdquo;,&ldquo;n&rdquo;,&ldquo;n&rdquo;,&ldquo;a&rdquo;,&ldquo;h&rdquo;] 输出：[&ldquo;h&rdquo;,&ldquo;a&rdquo;,&ldquo;n&rdquo;,&ldquo;n&rdquo;,&ldquo;a&rdquo;,&ldquo;H&rdquo;]
题解 class Solution { public void reverseString(char[] s) { // 重复子过程: 从区间 [0, len - 1] 两端取出两个元素, 交换之, 并收敛双指针; int l = 0, r = s.length - 1; while(l &lt; r) { char tmp = s[l]; s[l] = s[r]; s[r] = tmp; l++; r--; } } } 说明循环总会结束 while 循环中总会 l++, r&ndash;, 总会压缩解空间, 所以一定会结束, 不会死循环;</div></article><article class="list__item post"><header class=list__header><h3 class="list__title post__title"><a href=/halley/%E7%AE%97%E6%B3%95/%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-75/ rel=bookmark>颜色分类 75</a></h3><div class="list__meta meta"><div class="meta__item-datetime meta__item"><svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg><time class=meta__text datetime=2020-10-07T10:37:33+08:00>October 07, 2020</time></div></div></header><div class="content list__excerpt post__content clearfix">75. 颜色分类 颜色分类 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
注意: 不能使用代码库中的排序函数来解决这道题。
示例:
输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶：
一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？
双指针法 思路是: 使用两个指针left, right, 和另外一个指针 i 扫描为分类区域; 其中
left 定义最左面放置数字“0”的区间的右边界; right定义最右面放置数字“2”的区间的左边界; 循环过程中通过迭代i,将0和2交换到左右区间, 直到 i > right得到期望的结果。
我们先给出源码, 然后通过循环不变式证明while循环的正确性;
private static void sortColor(int[] color) { // left : 下一个0 将要放置的位置; [-oo , left) // right: 下一个2 将要放置的位置; (right, +oo] // i : 待分类的元素位置; [left, i) 存放数据 1 ( 且left &lt; i有效, 否则表示为检测到1) // [i, right] 为未分类区间; // 当未分类区间为空时候终止, 即 i > right, 最后一个未分类元素为 i == right; int i = 0, left = 0, right = color.</div></article></main><div class=pagination><a class="pagination__item pagination__item--prev btn" href=/halley/>«</a>
<span class="pagination__item pagination__item--current">2/2</span></div></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH... name=q aria-label=SEARCH...></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://halley-eng.github.io/halley/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F_463/>岛屿数量_463</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E9%95%BF%E6%8C%89%E9%94%AE%E5%85%A5-925/>长按键入 925</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8-143/>重排链表 143</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-844/>比较含退格的字符串 844</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-19/>删除链表的倒数第N个节点 19</a></li></ul></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2020 月亮惹的祸.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/halley/js/menu.js></script></body></html>