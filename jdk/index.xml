<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JDK 源码解析 on 月亮惹的祸</title><link>https://halley-eng.github.io/halley/jdk/</link><description>Recent content in JDK 源码解析 on 月亮惹的祸</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Wed, 07 Oct 2020 10:37:33 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/jdk/index.xml" rel="self" type="application/rss+xml"/><item><title>集合之HashMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</link><pubDate>Mon, 26 Oct 2020 00:28:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</guid><description>[TOC]
关键知识点分解 数据结构 构造方法 插入过程 hash定位算法; 红黑树插入 链表插入 链表插入触发树化过程; 删除过程 迭代器 LinkedHashMap 钩子函数 uml 数据结构 核心属性如下:
transient Node&amp;lt;K,V&amp;gt;[] table; transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet; transient int size; transient int modCount; int threshold; final float loadFactor; 4个构造方法 容量 + 负载因子构造
initialCapacity : 检测有效性及赋值; loadFactor : 检测有效性及赋值; 设置初始阈值为 最小满足的2次方数; public HashMap(int initialCapacity, float loadFactor) { // 检测容量有效性; 太小则报错; if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&amp;#34;Illegal initial capacity: &amp;#34; + initialCapacity); // 太大则取最大值; if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 检测负载因子的有效性; if (loadFactor &amp;lt;= 0 || Float.</description></item><item><title>集合之ArrayDeque</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</link><pubDate>Wed, 14 Oct 2020 01:49:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</guid><description>核心点 初始化 关键函数 头部新增 尾部新增 头尾新增对比 头部删除 尾部删除 任意位置删除 扩缩容 迭代器 DeqIterator DescendingIterator DeqSpliterator 三种初始化方法 1. 无参默认16个 public ArrayDeque() { elements = new Object[16]; } 2. 指定参数最少8个或者2的n次方个 默认最小申请8个 否则申请 &amp;gt;= 当前需要容量的 2的n次方个; 通过无符号右移 1、2、4、8、16 位分别保证 连续的 2、4、6、16、32 位都是 1 在 + 1 得到最近的 2的n次方 public ArrayDeque(int numElements) { allocateElements(numElements); } private void allocateElements(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements.</description></item><item><title>集合之LinkedList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</link><pubDate>Sun, 11 Oct 2020 20:58:34 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</guid><description>核心点 链表数据结构; 链表基本操作; 迭代器 位置定位 链表数据结构; 双链表包含 prev 和 next 两个指针;
private static class Node&amp;lt;E&amp;gt; { E item; Node&amp;lt;E&amp;gt; next; Node&amp;lt;E&amp;gt; prev; Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) { this.item = element; this.next = next; this.prev = prev; } } 双链表基本操作 头部新增 缓存旧头节点: f 创建新节点并升级为头节点 first 新节点next指针指向旧的头节点 处理旧头节点: f null : 新节点同时更新到last 否则其pre节点指向新节点; /** * Links e as first element. */ private void linkFirst(E e) { final Node&amp;lt;E&amp;gt; f = first; final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.</description></item><item><title>集合之ArrayList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</link><pubDate>Sat, 10 Oct 2020 18:28:19 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</guid><description>三种不同的初始化方法
扩缩容机制
null元素的特殊处理
removeIf 基于BitSet的实现;
序列化和反序列化
迭代器之内部类 ListItr,Itr
视图之内部类 SubList
底层数组修饰符transient有什么用?
ArrayListSpliterator
transient Object[] elementData;
三种不同的初始化方法 指定容量初始化 容量为0时底层数组指向空数组; 容量有效则按需申请; 负数容量抛出异常 public ArrayList(int initialCapacity) { if (initialCapacity &amp;gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&amp;#34;Illegal Capacity: &amp;#34;+ initialCapacity); } } 默认空数组初始化 public ArrayList() { this.</description></item><item><title>集合之Vector</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</link><pubDate>Thu, 08 Oct 2020 23:59:32 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</guid><description>关键点拆分如下:
扩缩容机制 迭代器实现 普通迭代器 列表迭代器 并行迭代器 视图实现 子列表视图 随机访问视图 扩容机制 在新增元素的时候, 确保容量足够
private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &amp;gt; 0) grow(minCapacity); } /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.</description></item><item><title>集合包</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</link><pubDate>Thu, 08 Oct 2020 16:22:17 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</guid><description>计划通过如下两个视角来总结相关实现;
结构视角: High Level 俯视 聚焦视角: 每个类的每个方法详细解说; 集合包结构视图 聚焦计划及进度 目前先只考虑非并发集合实现
List
Vector ArrayList LinkedList CopyOnWriteArrayList Queue
LinkedList ArrayDeque ConcurrentLinkedDeque BlockingDeque Set
LinkedHashSet TreeSet Map
IdentityHashMap&amp;lt;K,V&amp;gt; HashMap&amp;lt;K,V&amp;gt; LinkedHashMap&amp;lt;K,V&amp;gt; ConcurrentSkipListMap&amp;lt;K,V&amp;gt; TreeMap&amp;lt;K,V&amp;gt; WeakHashMap&amp;lt;K,V&amp;gt; Hashtable&amp;lt;K,V&amp;gt; Properties 共 14 篇</description></item></channel></rss>