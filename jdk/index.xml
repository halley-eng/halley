<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JDK 源码解析 on 月亮</title><link>https://halley-eng.github.io/halley/jdk/</link><description>Recent content in JDK 源码解析 on 月亮</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Wed, 07 Oct 2020 10:37:33 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/jdk/index.xml" rel="self" type="application/rss+xml"/><item><title>并发编程框架 ExecutorCompletionService</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-executorcompletionservice/</link><pubDate>Wed, 25 Nov 2020 21:44:15 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-executorcompletionservice/</guid><description>提交任务 public Future&amp;lt;V&amp;gt; submit(Callable&amp;lt;V&amp;gt; task) { if (task == null) throw new NullPointerException(); // 创建任务; RunnableFuture&amp;lt;V&amp;gt; f = newTaskFor(task); // 封装任务并将其提交到执行器; executor.execute(new QueueingFuture(f)); return f; } 封装任务是为了在任务执行完毕后能够接收任务完成信号
/** * FutureTask extension to enqueue upon completion */ private class QueueingFuture extends FutureTask&amp;lt;Void&amp;gt; { QueueingFuture(RunnableFuture&amp;lt;V&amp;gt; task) { super(task, null); this.task = task; } // 任务完成后 将任务添加到完成队列; protected void done() { completionQueue.add(task); } private final Future&amp;lt;V&amp;gt; task; } 完成任务的获取 任务的获取主要是封装了queue的api 支持三种模式</description></item><item><title>并发编程框架 AbstractQueuedSynchronizer 独占和共享锁</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E7%8B%AC%E5%8D%A0%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81/</link><pubDate>Wed, 25 Nov 2020 21:39:51 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E7%8B%AC%E5%8D%A0%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81/</guid><description>独占锁加锁(不响应超时和中断) 通过互斥量state获取锁: 尝试使用CAS更改状态,
如果能够获取成功, 则直接获取锁, 退出; 获取失败, 进入等待队列 addWaiter(Node.EXCLUSIVE) acquireQueued public final void acquire(int arg) { /** * {@link ReentrantLock.NonfairSync#tryAcquire(int)} 非公平方式获取锁 * * 1. 先尝试(使用CAS)获独占锁; * 2. 没有获得独占锁, 将自己作为一个独占节点并加入等待队列, * 之后在 acquireQueued 中进入不断等待的时期; * */ if (!tryAcquire(arg) &amp;amp;&amp;amp; // 先尝试获取独占锁, 如果没有申请到锁 才往下走 // 1. 将当前线程加入到同步队列,并且其占用模式为独占形式 // 2. 当前线程wait并等待自己的节点的状态 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 获取锁 获取锁的函数如下, 其需要子类，根据场景不同(是否公平锁、是否共享锁等)做不同的实现
protected boolean tryAcquire(int arg) { throw new UnsupportedOperationException(); } 然后，不能获取锁会将当前线程封装成为一个等待节点, 并加入到CLH队列</description></item><item><title>并发编程框架 AbstractQueuedSynchronizer 条件变量</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link><pubDate>Wed, 25 Nov 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-abstractqueuedsynchronizer-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid><description>wait 去竞争锁 将当前线程加入条件队列 释放当前状态变量 state 个 等待其被转移至竞争队列CLH 等待获取锁, 获取状态变量state个 /** * Implements interruptible condition wait. * &amp;lt;ol&amp;gt; * &amp;lt;li&amp;gt; If current thread is interrupted, throw InterruptedException. * &amp;lt;li&amp;gt; Save lock state returned by {@link #getState}. * &amp;lt;li&amp;gt; Invoke {@link #release} with saved state as argument, * throwing IllegalMonitorStateException if it fails. * &amp;lt;li&amp;gt; Block until signalled or interrupted. 在被通知或者中断之前阻塞当前线程 * &amp;lt;li&amp;gt; Reacquire by invoking specialized version of * {@link #acquire} with saved state as argument.</description></item><item><title>并发编程框架 CountDown</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-countdownlatch/</link><pubDate>Wed, 25 Nov 2020 21:38:02 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-countdownlatch/</guid><description>CountDownLatch 仅有一个sync属性， 并且是根据AQS自定义的Sync类型
Sync 实现 private static final class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 4982264981922014374L; Sync(int count) { setState(count); } int getCount() { return getState(); } protected int tryAcquireShared(int acquires) { // 直到剩余可获取信号量为0的时候 才能获取到共享锁; return (getState() == 0) ? 1 : -1; } protected boolean tryReleaseShared(int releases) { // Decrement count; signal when transition to zero for (;;) { // 拿状态 int c = getState(); // 如果为0 则已经释放过了, 这次直接释放失败, 保证只释放一次 if (c == 0) return false; // 设置下一次释放后锁的数量; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; } } } countdown 信号量到 0 级联唤醒等待者 用户调用countdown函数, 底层是释放共享锁</description></item><item><title>并发编程框架 CyclicBarrier</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-cyclicbarrier/</link><pubDate>Wed, 25 Nov 2020 21:37:30 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-cyclicbarrier/</guid><description>数据结构 /** * 锁屏障 * The lock for guarding barrier entry */ private final ReentrantLock lock = new ReentrantLock(); /** * 条件变量 * Condition to wait on until tripped */ private final Condition trip = lock.newCondition(); /** 参与方数量 The number of parties */ private final int parties; /* 各参与方都到位后的触发命令 The command to run when tripped */ private final Runnable barrierCommand; /** 当前代 The current generation */ private Generation generation = new Generation(); /** * 当前代未到位的参与方数量 * Number of parties still waiting.</description></item><item><title>并发编程框架 Semaphore</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-semaphore/</link><pubDate>Wed, 25 Nov 2020 21:36:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-semaphore/</guid><description>同步器Sync实现 将AQS中的state变量, 映射到Sempaphore的permit变量; 使用for(;;) + case的形式写获取和释放信号量的逻辑 /** * Synchronization implementation for semaphore. Uses AQS state * to represent permits. Subclassed into fair and nonfair * versions. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = 1192457210091910933L; // 1. 将AQS中的state变量, 映射到Sempaphore的permit变量; // 许可数存放在state字段里面; Sync(int permits) { setState(permits); } // 在将state翻译成permits final int getPermits() { return getState(); } // 2. 使用for(;;) + case的形式写获取和释放信号量的逻辑 /* 非公平获取锁 */ final int nonfairTryAcquireShared(int acquires) { for (;;) { // 确实没有剩下多少 int available = getState(); int remaining = available - acquires; // 尝试修改剩余许可证数量 if (remaining &amp;lt; 0 || compareAndSetState(available, remaining)) return remaining; } } protected final boolean tryReleaseShared(int releases) { for (;;) { int current = getState(); int next = current + releases; if (next &amp;lt; current) // overflow throw new Error(&amp;#34;Maximum permit count exceeded&amp;#34;); if (compareAndSetState(current, next)) return true; } } final void reducePermits(int reductions) { for (;;) { int current = getState(); int next = current - reductions; if (next &amp;gt; current) // underflow throw new Error(&amp;#34;Permit count underflow&amp;#34;); if (compareAndSetState(current, next)) return; } } final int drainPermits() { for (;;) { int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; } } } 非公平 /** * NonFair version */ static final class NonfairSync extends Sync { private static final long serialVersionUID = -2694183684443567898L; /** * 利用Sync中的同步变量 初始化permits数 */ NonfairSync(int permits) { super(permits); } /** * 尝试获取许可证 */ protected int tryAcquireShared(int acquires) { return nonfairTryAcquireShared(acquires); } } 公平同步器 公平同步器, 通过状态的修改必然依赖于队列中是否有已等待的节点; 来保证新线程, 不会和队列中的线程进行抢占来实现;</description></item><item><title>并发编程框架 ReentrantLock</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantlock/</link><pubDate>Wed, 25 Nov 2020 21:36:05 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantlock/</guid><description>同步器 /** * Base of synchronization control for this lock. Subclassed * into fair and nonfair versions below. Uses AQS state to * represent the number of holds on the lock. */ abstract static class Sync extends AbstractQueuedSynchronizer { private static final long serialVersionUID = -5179523762034025860L; /** * 锁定操作 * * Performs {@link Lock#lock}. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * 1.</description></item><item><title>并发编程框架 ReentrantReadWriteLock</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantreadwritelock/</link><pubDate>Wed, 25 Nov 2020 21:35:01 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-reentrantreadwritelock/</guid><description>构造 读写锁都是对 ReentrantReadWriteLock 中的同步器sync的封装，会共享其中的state变量
/** * Creates a new {@code ReentrantReadWriteLock} with * default (nonfair) ordering properties. */ public ReentrantReadWriteLock() { this(false); } /** * Creates a new {@code ReentrantReadWriteLock} with * the given fairness policy. * * @param fair {@code true} if this lock should use a fair ordering policy */ public ReentrantReadWriteLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this); } public ReentrantReadWriteLock.</description></item><item><title>并发编程框架 FutureTask</title><link>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-futuretask/</link><pubDate>Wed, 25 Nov 2020 21:30:47 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6-futuretask/</guid><description>Future模式 Future代表异步执行结果. 用户可以
调用get方法获取执行结果 调用cancel方法取消执行 调用get(long, TimeUnit) 支持超时的获取结果; 内存一致性保证: 异步计算 happen-before 另外一个线程的Future.get
RunnableFuture实现 用于定义一种Future, 同时也是一个Runnable. 一旦该Runnable运行完成, 那么该Future就能得到结果;
/** * A {@link Future} that is {@link Runnable}. Successful execution of * the {@code run} method causes completion of the {@code Future} * and allows access to its results. * @see FutureTask * @see Executor * @since 1.6 * @author Doug Lea * @param &amp;lt;V&amp;gt; The result type returned by this Future&amp;#39;s {@code get} method */ public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; { /** * Sets this Future to the result of its computation * unless it has been cancelled.</description></item><item><title>集合之ConcurrentSkipListMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bconcurrentskiplistmap/</link><pubDate>Mon, 02 Nov 2020 00:53:30 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bconcurrentskiplistmap/</guid><description>结构图 总图 下面对几个接口重点说明:
SortedMap: 提供排序器查询、区间视图、头尾访问等 ConcurrentMap:
不支持null值; 所以重写了Map接口中相关默认实现为不实现 提供线程安全和原子保证; 所以重写了Map接口中相关默认实现 ConcurrentNavigableMap
重写了NavigableMap接口方法的返回类型为ConcurrentNavigableMap 源码解析 数据结构 查询 新增 删除 区间查询 迭代器 查询 注意两种情况下找不到节点:
当前节点为null, 不可能匹配key; 前缀节点为header节点, 则没有找到前缀, key太大了, 不可能匹配key /** * Gets value for key. Almost the same as findNode, but returns * the found value (to avoid retries during re-reads) * * @param key the key * @return the value, or null if absent */ private V doGet(Object key) { if (key == null) throw new NullPointerException(); Comparator&amp;lt;?</description></item><item><title>集合之HashSet</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashset/</link><pubDate>Sat, 31 Oct 2020 14:58:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashset/</guid><description>插入 以参数e为key, value固定为常量 PRESENT 插入到map.
通过map的key的唯一性保证集合的唯一性; 因为底层是HashMap, 所以并不能保证有序; public boolean add(E e) { return m.put(e, PRESENT)==null; } 删除 如果字典能成功删除对象o, 并且其值为PRESENT时.
public boolean remove(Object o) { return m.remove(o)==PRESENT; } 异常处理 因为TreeSet需要依赖key的有序性来处理问题, 所以会产生下面的异常:
ClassCastException: 当输入的key不能与字段中存量的key比较时; NullPointerException: 当输入的key为null, 并且比较器不兼容null值时，或者没有比较器时;
但是HashSet并不需要有序性保证，而且key支持null, 所以甚至没有npe异常;
其他 利用key在底层字典中只保证唯一性 不保证有序性, 所以TreeSet没有提供导航接口。</description></item><item><title>集合之TreeSet</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreeset/</link><pubDate>Sat, 31 Oct 2020 14:35:59 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreeset/</guid><description>核心点分解 插入 以参数e为key, value固定为常量 PRESENT 插入到map.
通过map的key的唯一性保证集合的唯一性. 通过map的有序性保证集合的有序性. public boolean add(E e) { return m.put(e, PRESENT)==null; } 删除 如果字典能成功删除对象o, 并且其值为PRESENT时.
public boolean remove(Object o) { return m.remove(o)==PRESENT; } 异常处理 ClassCastException: 当输入的key不能与字段中存量的key比较时;
NullPointerException: 当输入的key为null, 并且比较器不兼容null值时，或者没有比较器时;
其他 利用key在底层字典中的有序性, 所以TreeSet也能提供相关导航接口.</description></item><item><title>集合之TreeMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreemap/</link><pubDate>Fri, 30 Oct 2020 22:16:46 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreemap/</guid><description>核心点分解 插入过程 删除过程 导航方法 lowerEntry floorEntry ceilingEntry higherEntry 视图 headMap subMap tailMap 迭代器 查询 firstKey lastKey 插入 两种情况下返回null
根节点root == null 遍历整颗树后依然没有发现已存在的节点 空指针异常:
当key为null, 且没有指定comparator， 使用key对象的compareTo(T t); 存在排序器 comparator 但是其不支持; ClassCastException:
当没有制定排序器时，会提取Key值的 Compareble接口, 如果不能cast到则会抛出对应的ClassCastException public V put(K key, V value) { // 本地化根节点 root 到 t; Entry&amp;lt;K,V&amp;gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check // 初始化root节点; root = new Entry&amp;lt;&amp;gt;(key, value, null); size = 1; modCount++; // 返回旧节点为null; return null; } int cmp; Entry&amp;lt;K,V&amp;gt; parent; // split comparator and comparable paths Comparator&amp;lt;?</description></item><item><title>集合之LinkedHashMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedhashmap/</link><pubDate>Tue, 27 Oct 2020 21:53:21 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedhashmap/</guid><description>核心点分解 数据结构 构造方法 链表特殊操作 查询 迭代器 视图 数据结构 // 链表头指针 transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head; // 链表尾指针 transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail; // 是否维持访问序 final boolean accessOrder; 构造方法 在HashMap的所有构造方法上, 都加上了 accessOrder 属性
/** * Constructs an empty insertion-ordered &amp;lt;tt&amp;gt;LinkedHashMap&amp;lt;/tt&amp;gt; instance * with the specified initial capacity and a default load factor (0.75). * * @param initialCapacity the initial capacity * @throws IllegalArgumentException if the initial capacity is negative */ public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } /** * Constructs an empty insertion-ordered &amp;lt;tt&amp;gt;LinkedHashMap&amp;lt;/tt&amp;gt; instance * with the default initial capacity (16) and load factor (0.</description></item><item><title>集合之HashMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</link><pubDate>Mon, 26 Oct 2020 00:28:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</guid><description>[TOC]
关键知识点分解 数据结构 构造方法 插入过程 hash定位算法; 红黑树插入 链表插入 链表插入触发树化过程; 删除过程 迭代器 LinkedHashMap 钩子函数 uml 数据结构 核心属性如下:
transient Node&amp;lt;K,V&amp;gt;[] table; transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet; transient int size; transient int modCount; int threshold; final float loadFactor; 4个构造方法 容量 + 负载因子构造
initialCapacity : 检测有效性及赋值; loadFactor : 检测有效性及赋值; 设置初始阈值为 最小满足的2次方数; public HashMap(int initialCapacity, float loadFactor) { // 检测容量有效性; 太小则报错; if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&amp;#34;Illegal initial capacity: &amp;#34; + initialCapacity); // 太大则取最大值; if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 检测负载因子的有效性; if (loadFactor &amp;lt;= 0 || Float.</description></item><item><title>集合之ArrayDeque</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</link><pubDate>Wed, 14 Oct 2020 01:49:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</guid><description>核心点 初始化 关键函数 头部新增 尾部新增 头尾新增对比 头部删除 尾部删除 任意位置删除 扩缩容 迭代器 DeqIterator DescendingIterator DeqSpliterator 三种初始化方法 1. 无参默认16个 public ArrayDeque() { elements = new Object[16]; } 2. 指定参数最少8个或者2的n次方个 默认最小申请8个 否则申请 &amp;gt;= 当前需要容量的 2的n次方个; 通过无符号右移 1、2、4、8、16 位分别保证 连续的 2、4、6、16、32 位都是 1 在 + 1 得到最近的 2的n次方 public ArrayDeque(int numElements) { allocateElements(numElements); } private void allocateElements(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements.</description></item><item><title>集合之LinkedList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</link><pubDate>Sun, 11 Oct 2020 20:58:34 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</guid><description>核心点 链表数据结构; 链表基本操作; 迭代器 位置定位 链表数据结构; 双链表包含 prev 和 next 两个指针;
private static class Node&amp;lt;E&amp;gt; { E item; Node&amp;lt;E&amp;gt; next; Node&amp;lt;E&amp;gt; prev; Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) { this.item = element; this.next = next; this.prev = prev; } } 双链表基本操作 头部新增 缓存旧头节点: f 创建新节点并升级为头节点 first 新节点next指针指向旧的头节点 处理旧头节点: f null : 新节点同时更新到last 否则其pre节点指向新节点; /** * Links e as first element. */ private void linkFirst(E e) { final Node&amp;lt;E&amp;gt; f = first; final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.</description></item><item><title>集合之ArrayList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</link><pubDate>Sat, 10 Oct 2020 18:28:19 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</guid><description>三种不同的初始化方法
扩缩容机制
null元素的特殊处理
removeIf 基于BitSet的实现;
序列化和反序列化
迭代器之内部类 ListItr,Itr
视图之内部类 SubList
底层数组修饰符transient有什么用?
ArrayListSpliterator
transient Object[] elementData;
三种不同的初始化方法 指定容量初始化 容量为0时底层数组指向空数组; 容量有效则按需申请; 负数容量抛出异常 public ArrayList(int initialCapacity) { if (initialCapacity &amp;gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&amp;#34;Illegal Capacity: &amp;#34;+ initialCapacity); } } 默认空数组初始化 public ArrayList() { this.</description></item><item><title>集合之Vector</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</link><pubDate>Thu, 08 Oct 2020 23:59:32 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</guid><description>关键点拆分如下:
扩缩容机制 迭代器实现 普通迭代器 列表迭代器 并行迭代器 视图实现 子列表视图 随机访问视图 扩容机制 在新增元素的时候, 确保容量足够
private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &amp;gt; 0) grow(minCapacity); } /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.</description></item><item><title>集合包</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</link><pubDate>Thu, 08 Oct 2020 16:22:17 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</guid><description>计划通过如下两个视角来总结相关实现;
结构视角: High Level 俯视 聚焦视角: 每个类的每个方法详细解说; 集合包结构视图 聚焦计划及进度 目前先只考虑非并发集合实现
List
Vector ArrayList LinkedList CopyOnWriteArrayList Queue
LinkedList ArrayDeque ConcurrentLinkedDeque BlockingDeque Set
LinkedHashSet TreeSet Map
IdentityHashMap&amp;lt;K,V&amp;gt; HashMap&amp;lt;K,V&amp;gt; LinkedHashMap&amp;lt;K,V&amp;gt; ConcurrentSkipListMap&amp;lt;K,V&amp;gt; TreeMap&amp;lt;K,V&amp;gt; WeakHashMap&amp;lt;K,V&amp;gt; Hashtable&amp;lt;K,V&amp;gt; Properties 共 14 篇</description></item><item><title/><link>https://halley-eng.github.io/halley/jdk/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8Bguava_-listenablefuture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8Bguava_-listenablefuture/</guid><description>title: &amp;ldquo;异步编程之CompletableFuture&amp;rdquo; date: 2020-12-30T21:39:16+08:00 draft: true tags: [&amp;ldquo;并发&amp;rdquo;]
创建 通过包装线程池 相对于 JDK 提供的 ExecutorService.submit(Callable) 形式去创建异步计算任务， Guava 提供 ListeningExecutorService 相对于将原来返回的 Future 切换成 ListenableFuture 两者可以通过 MoreExecutors.listeningDecorator(ExecutorService) 实现转换 ListeningExecutorService service = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10)); ListenableFuture&amp;lt;Explosion&amp;gt; explosion = service.submit( new Callable&amp;lt;Explosion&amp;gt;() { public Explosion call() { return pushBigRedButton(); } }); Futures.addCallback( explosion, new FutureCallback&amp;lt;Explosion&amp;gt;() { // we want this handler to run immediately after we push the big red button! public void onSuccess(Explosion explosion) { walkAwayFrom(explosion); } public void onFailure(Throwable thrown) { battleArchNemesis(); // escaped the explosion!</description></item></channel></rss>