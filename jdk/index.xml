<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JDK 源码解析 on 月亮惹的祸</title><link>https://halley-eng.github.io/halley/jdk/</link><description>Recent content in JDK 源码解析 on 月亮惹的祸</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Wed, 07 Oct 2020 10:37:33 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/jdk/index.xml" rel="self" type="application/rss+xml"/><item><title>集合之HashSet</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashset/</link><pubDate>Sat, 31 Oct 2020 14:58:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashset/</guid><description>插入 以参数e为key, value固定为常量 PRESENT 插入到map.
通过map的key的唯一性保证集合的唯一性; 因为底层是HashMap, 所以并不能保证有序; public boolean add(E e) { return m.put(e, PRESENT)==null; } 删除 如果字典能成功删除对象o, 并且其值为PRESENT时.
public boolean remove(Object o) { return m.remove(o)==PRESENT; } 异常处理 因为TreeSet需要依赖key的有序性来处理问题, 所以会产生下面的异常:
ClassCastException: 当输入的key不能与字段中存量的key比较时; NullPointerException: 当输入的key为null, 并且比较器不兼容null值时，或者没有比较器时;
但是HashSet并不需要有序性保证，而且key支持null, 所以甚至没有npe异常;
其他 利用key在底层字典中只保证唯一性 不保证有序性, 所以TreeSet没有提供导航接口。</description></item><item><title>集合之TreeSet</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreeset/</link><pubDate>Sat, 31 Oct 2020 14:35:59 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreeset/</guid><description>核心点分解 插入 以参数e为key, value固定为常量 PRESENT 插入到map.
通过map的key的唯一性保证集合的唯一性. 通过map的有序性保证集合的有序性. public boolean add(E e) { return m.put(e, PRESENT)==null; } 删除 如果字典能成功删除对象o, 并且其值为PRESENT时.
public boolean remove(Object o) { return m.remove(o)==PRESENT; } 异常处理 ClassCastException: 当输入的key不能与字段中存量的key比较时;
NullPointerException: 当输入的key为null, 并且比较器不兼容null值时，或者没有比较器时;
其他 利用key在底层字典中的有序性, 所以TreeSet也能提供相关导航接口.</description></item><item><title>集合之TreeMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreemap/</link><pubDate>Fri, 30 Oct 2020 22:16:46 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Btreemap/</guid><description>核心点分解 插入过程 删除过程 导航方法 lowerEntry floorEntry ceilingEntry higherEntry 视图 headMap subMap tailMap 迭代器 查询 firstKey lastKey 插入 两种情况下返回null
根节点root == null 遍历整颗树后依然没有发现已存在的节点 空指针异常:
当key为null, 且没有指定comparator， 使用key对象的compareTo(T t); 存在排序器 comparator 但是其不支持; ClassCastException:
当没有制定排序器时，会提取Key值的 Compareble接口, 如果不能cast到则会抛出对应的ClassCastException public V put(K key, V value) { // 本地化根节点 root 到 t; Entry&amp;lt;K,V&amp;gt; t = root; if (t == null) { compare(key, key); // type (and possibly null) check // 初始化root节点; root = new Entry&amp;lt;&amp;gt;(key, value, null); size = 1; modCount++; // 返回旧节点为null; return null; } int cmp; Entry&amp;lt;K,V&amp;gt; parent; // split comparator and comparable paths Comparator&amp;lt;?</description></item><item><title>集合之LinkedHashMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedhashmap/</link><pubDate>Tue, 27 Oct 2020 21:53:21 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedhashmap/</guid><description>核心点分解 数据结构 构造方法 链表特殊操作 查询 迭代器 视图 数据结构 // 链表头指针 transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; head; // 链表尾指针 transient LinkedHashMap.Entry&amp;lt;K,V&amp;gt; tail; // 是否维持访问序 final boolean accessOrder; 构造方法 在HashMap的所有构造方法上, 都加上了 accessOrder 属性
/** * Constructs an empty insertion-ordered &amp;lt;tt&amp;gt;LinkedHashMap&amp;lt;/tt&amp;gt; instance * with the specified initial capacity and a default load factor (0.75). * * @param initialCapacity the initial capacity * @throws IllegalArgumentException if the initial capacity is negative */ public LinkedHashMap(int initialCapacity) { super(initialCapacity); accessOrder = false; } /** * Constructs an empty insertion-ordered &amp;lt;tt&amp;gt;LinkedHashMap&amp;lt;/tt&amp;gt; instance * with the default initial capacity (16) and load factor (0.</description></item><item><title>集合之HashMap</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</link><pubDate>Mon, 26 Oct 2020 00:28:37 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bhashmap/</guid><description>[TOC]
关键知识点分解 数据结构 构造方法 插入过程 hash定位算法; 红黑树插入 链表插入 链表插入触发树化过程; 删除过程 迭代器 LinkedHashMap 钩子函数 uml 数据结构 核心属性如下:
transient Node&amp;lt;K,V&amp;gt;[] table; transient Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt; entrySet; transient int size; transient int modCount; int threshold; final float loadFactor; 4个构造方法 容量 + 负载因子构造
initialCapacity : 检测有效性及赋值; loadFactor : 检测有效性及赋值; 设置初始阈值为 最小满足的2次方数; public HashMap(int initialCapacity, float loadFactor) { // 检测容量有效性; 太小则报错; if (initialCapacity &amp;lt; 0) throw new IllegalArgumentException(&amp;#34;Illegal initial capacity: &amp;#34; + initialCapacity); // 太大则取最大值; if (initialCapacity &amp;gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 检测负载因子的有效性; if (loadFactor &amp;lt;= 0 || Float.</description></item><item><title>集合之ArrayDeque</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</link><pubDate>Wed, 14 Oct 2020 01:49:55 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraydeque/</guid><description>核心点 初始化 关键函数 头部新增 尾部新增 头尾新增对比 头部删除 尾部删除 任意位置删除 扩缩容 迭代器 DeqIterator DescendingIterator DeqSpliterator 三种初始化方法 1. 无参默认16个 public ArrayDeque() { elements = new Object[16]; } 2. 指定参数最少8个或者2的n次方个 默认最小申请8个 否则申请 &amp;gt;= 当前需要容量的 2的n次方个; 通过无符号右移 1、2、4、8、16 位分别保证 连续的 2、4、6、16、32 位都是 1 在 + 1 得到最近的 2的n次方 public ArrayDeque(int numElements) { allocateElements(numElements); } private void allocateElements(int numElements) { int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements.</description></item><item><title>集合之LinkedList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</link><pubDate>Sun, 11 Oct 2020 20:58:34 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Blinkedlist/</guid><description>核心点 链表数据结构; 链表基本操作; 迭代器 位置定位 链表数据结构; 双链表包含 prev 和 next 两个指针;
private static class Node&amp;lt;E&amp;gt; { E item; Node&amp;lt;E&amp;gt; next; Node&amp;lt;E&amp;gt; prev; Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) { this.item = element; this.next = next; this.prev = prev; } } 双链表基本操作 头部新增 缓存旧头节点: f 创建新节点并升级为头节点 first 新节点next指针指向旧的头节点 处理旧头节点: f null : 新节点同时更新到last 否则其pre节点指向新节点; /** * Links e as first element. */ private void linkFirst(E e) { final Node&amp;lt;E&amp;gt; f = first; final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.</description></item><item><title>集合之ArrayList</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</link><pubDate>Sat, 10 Oct 2020 18:28:19 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Barraylist/</guid><description>三种不同的初始化方法
扩缩容机制
null元素的特殊处理
removeIf 基于BitSet的实现;
序列化和反序列化
迭代器之内部类 ListItr,Itr
视图之内部类 SubList
底层数组修饰符transient有什么用?
ArrayListSpliterator
transient Object[] elementData;
三种不同的初始化方法 指定容量初始化 容量为0时底层数组指向空数组; 容量有效则按需申请; 负数容量抛出异常 public ArrayList(int initialCapacity) { if (initialCapacity &amp;gt; 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(&amp;#34;Illegal Capacity: &amp;#34;+ initialCapacity); } } 默认空数组初始化 public ArrayList() { this.</description></item><item><title>集合之Vector</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</link><pubDate>Thu, 08 Oct 2020 23:59:32 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E4%B9%8Bvector/</guid><description>关键点拆分如下:
扩缩容机制 迭代器实现 普通迭代器 列表迭代器 并行迭代器 视图实现 子列表视图 随机访问视图 扩容机制 在新增元素的时候, 确保容量足够
private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &amp;gt; 0) grow(minCapacity); } /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.</description></item><item><title>集合包</title><link>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</link><pubDate>Thu, 08 Oct 2020 16:22:17 +0800</pubDate><guid>https://halley-eng.github.io/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/</guid><description>计划通过如下两个视角来总结相关实现;
结构视角: High Level 俯视 聚焦视角: 每个类的每个方法详细解说; 集合包结构视图 聚焦计划及进度 目前先只考虑非并发集合实现
List
Vector ArrayList LinkedList CopyOnWriteArrayList Queue
LinkedList ArrayDeque ConcurrentLinkedDeque BlockingDeque Set
LinkedHashSet TreeSet Map
IdentityHashMap&amp;lt;K,V&amp;gt; HashMap&amp;lt;K,V&amp;gt; LinkedHashMap&amp;lt;K,V&amp;gt; ConcurrentSkipListMap&amp;lt;K,V&amp;gt; TreeMap&amp;lt;K,V&amp;gt; WeakHashMap&amp;lt;K,V&amp;gt; Hashtable&amp;lt;K,V&amp;gt; Properties 共 14 篇</description></item></channel></rss>