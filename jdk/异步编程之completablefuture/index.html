<!doctype html><html class=no-js lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><title>- 月亮</title><script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script><meta name=description content><meta property="og:title" content><meta property="og:description" content="Future 接口介绍 JDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。
 阻塞的方式显然和我们的异步编程的初衷相违背， 轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，  为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。
有一些开源框架实现了我们的设想，例如 Netty 的 ChannelFuture 类扩展了 Future 接口，通过提供 addListener 方法实现支持回调方式的异步编程。Netty 中所有的 I/O 操作都是异步的,这意味着任何的 I/O 调用都将立即返回，而不保证这些被请求的 I/O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I/O 操作结果或者状态的信息。当一个 I/O 操作开始的时候，一个新的 Future 对象就会被创建。在开始的时候，新的 Future 是未完成的状态－－它既非成功、失败，也非被取消，因为 I/O 操作还没有结束。如果 I/O 操作以成功、失败或者被取消中的任何一种状态结束了，那么这个 Future 将会被标记为已完成，并包含更多详细的信息（例如：失败的原因）。请注意，即使是失败和被取消的状态，也是属于已完成的状态。
下面主要介绍下CompletableFuture的实现和相关源码解析;
同步执行动作 示例 static void thenApplyExample() { CompletableFuture<String> cf = CompletableFuture.completedFuture(&#34;message&#34;).thenApply(s -> { assertFalse(Thread.currentThread().isDaemon()); returns.toUpperCase(); }); assertEquals(&#34;MESSAGE&#34;, cf.getNow(null)); } 以上代码在计算正常完成的前提下将执行动作（此处为转换成大写字母）。
相关源码   接收任务API"><meta property="og:type" content="article"><meta property="og:url" content="https://halley-eng.github.io/halley/jdk/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E4%B9%8Bcompletablefuture/"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/halley/css/style.css><link rel="shortcut icon" href=/halley/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/halley/ title=月亮 rel=home><div class="logo__item logo__text"><div class=logo__title>月亮</div><div class=logo__tagline>每天进步一点点</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>Menu</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/halley/jdk/><i class="fa fa-road"></i><span class=menu__text>JDK</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/%E7%AE%97%E6%B3%95/><i class="fa fa-road"></i><span class=menu__text>算法</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/axon/><i class="fa fa-road"></i><span class=menu__text>Axon</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/><i class="fa fa-road"></i><span class=menu__text>源码阅读</span>
<span class=alert></span></a></li><li class=menu__item><a class=menu__link href=/halley/about/><span class=menu__text>关于作者</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title></h1></header><div class="content post__content clearfix"><h3 id=future-接口介绍>Future 接口介绍</h3><p>JDK5 新增了 Future 接口，用于描述一个异步计算的结果。虽然 Future 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。</p><ol><li>阻塞的方式显然和我们的异步编程的初衷相违背，</li><li>轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，</li></ol><p>为什么不能用观察者设计模式呢？即当计算结果完成及时通知监听者。</p><p>有一些开源框架实现了我们的设想，例如 Netty 的 ChannelFuture 类扩展了 Future 接口，通过提供 addListener 方法实现支持回调方式的异步编程。Netty 中所有的 I/O 操作都是异步的,这意味着任何的 I/O 调用都将立即返回，而不保证这些被请求的 I/O 操作在调用结束的时候已经完成。取而代之地，你会得到一个返回的 ChannelFuture 实例，这个实例将给你一些关于 I/O 操作结果或者状态的信息。当一个 I/O 操作开始的时候，一个新的 Future 对象就会被创建。在开始的时候，新的 Future 是未完成的状态－－它既非成功、失败，也非被取消，因为 I/O 操作还没有结束。如果 I/O 操作以成功、失败或者被取消中的任何一种状态结束了，那么这个 Future 将会被标记为已完成，并包含更多详细的信息（例如：失败的原因）。请注意，即使是失败和被取消的状态，也是属于已完成的状态。</p><p>下面主要介绍下CompletableFuture的实现和相关源码解析;</p><h3 id=同步执行动作>同步执行动作</h3><h4 id=示例>示例</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thenApplyExample</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> cf <span style=color:#f92672>=</span> CompletableFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>completedFuture</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;message&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>thenApply</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
    assertFalse<span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>isDaemon</span><span style=color:#f92672>());</span>
    returns<span style=color:#f92672>.</span><span style=color:#a6e22e>toUpperCase</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>});</span>
    assertEquals<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MESSAGE&#34;</span><span style=color:#f92672>,</span> cf<span style=color:#f92672>.</span><span style=color:#a6e22e>getNow</span><span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>));</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>以上代码在计算正常完成的前提下将执行动作（此处为转换成大写字母）。</p><h4 id=相关源码>相关源码</h4><ol><li><p>接收任务API</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * 对于当前的{@link CompletableFuture} 应用另外一个函数
</span><span style=color:#75715e>     * @param fn
</span><span style=color:#75715e>     * @param &lt;U&gt;
</span><span style=color:#75715e>     * @return
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>thenApply</span><span style=color:#f92672>(</span>
        Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,?</span> <span style=color:#66d9ef>extends</span> U<span style=color:#f92672>&gt;</span> fn<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// 不定义线程池的情况下去执行 fn;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> uniApplyStage<span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>,</span> fn<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
</code></pre></div><p>如上uniApplyStage第一个线程池参数位null, 所以是同步运行模式;</p></li><li><p>运行或者是封装Completion到队列</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>private</span> <span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>uniApplyStage</span><span style=color:#f92672>(</span>
        Executor e<span style=color:#f92672>,</span> Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,?</span> <span style=color:#66d9ef>extends</span> V<span style=color:#f92672>&gt;</span> f<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// 1. 检测依赖函数不能为null 
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>f <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>();</span>
        <span style=color:#75715e>// 2. 在当前Future中, 触发执行，并输出结果到 d
</span><span style=color:#75715e></span>        CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> d <span style=color:#f92672>=</span>  <span style=color:#66d9ef>new</span> CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;();</span>
        <span style=color:#75715e>// 执行目标过程 f
</span><span style=color:#75715e></span>        <span style=color:#75715e>// 两种情况封装任务UniApply执行 
</span><span style=color:#75715e></span>        <span style=color:#75715e>// 2.1. 定义了线程池e      2.2 再d中同步运行失败;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>d<span style=color:#f92672>.</span><span style=color:#a6e22e>uniApply</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> f<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// 定义一个任务, 去线程池中e中, 针对线程池中this 中执行f 并输出到d中;
</span><span style=color:#75715e></span>            UniApply<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> c <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UniApply<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;(</span>e<span style=color:#f92672>,</span> d<span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> f<span style=color:#f92672>);</span>
            <span style=color:#75715e>// 将任务c押入栈中;
</span><span style=color:#75715e></span>            push<span style=color:#f92672>(</span>c<span style=color:#f92672>);</span>
            <span style=color:#75715e>//  触发任务完成;
</span><span style=color:#75715e></span>            c<span style=color:#f92672>.</span><span style=color:#a6e22e>tryFire</span><span style=color:#f92672>(</span>SYNC<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>/**
</span><span style=color:#75715e>         *   返回融合后的{@link CompletableFuture}
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>return</span> d<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>

</code></pre></div><p>根据例子中的代码</p><ol><li>不走线程池的情况下, 在目标Future中执行, 并得到结果</li></ol></li><li><p>直接在新 CompletableFuture &ndash; d 中运行</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * 从依赖的{@link CompletableFuture} 中获取结果, 再执行函数f, 并拿到结果给到当前的{@link CompletableFuture}
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * @param a  数据来源 {@link CompletableFuture}
</span><span style=color:#75715e>     * @param f  即将引用的函数
</span><span style=color:#75715e>     * @param c
</span><span style=color:#75715e>     * @param &lt;S&gt;
</span><span style=color:#75715e>     * @return
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>final</span> <span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>uniApply</span><span style=color:#f92672>(</span>CompletableFuture<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span> a<span style=color:#f92672>,</span>
                               Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> S<span style=color:#f92672>,?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;</span> f<span style=color:#f92672>,</span>
                               UniApply<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>,</span>T<span style=color:#f92672>&gt;</span> c<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        Object r<span style=color:#f92672>;</span> Throwable x<span style=color:#f92672>;</span>
        <span style=color:#75715e>// 1. 来源Future a如果未完成, 当前任务不会被执行, 所以这里直接返回false;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>a <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>r <span style=color:#f92672>=</span> a<span style=color:#f92672>.</span><span style=color:#a6e22e>result</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> f <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
        <span style=color:#75715e>// 2. 来源Future 执行完成, 当前任务还没有拿到结果的情况下: 
</span><span style=color:#75715e></span>        tryComplete<span style=color:#f92672>:</span> <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>result <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

            <span style=color:#75715e>// 2.1. 设置异常运行的结果;
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>r <span style=color:#66d9ef>instanceof</span> AltResult<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// 传播异常;
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>x <span style=color:#f92672>=</span> <span style=color:#f92672>((</span>AltResult<span style=color:#f92672>)</span>r<span style=color:#f92672>).</span><span style=color:#a6e22e>ex</span><span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    completeThrowable<span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> r<span style=color:#f92672>);</span>
                    <span style=color:#66d9ef>break</span> tryComplete<span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
                r <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>

            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// 2.2 如果有定义线程池, 则通过c将当前任务提交到线程池在重新执行;
</span><span style=color:#75715e></span>                <span style=color:#75715e>// 定义了任务封装UniApply 并且如果里面有线程池, 
</span><span style=color:#75715e></span>                <span style=color:#75715e>// 则会优先使用之, 去运行该任务, 此后直接返回;
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>c<span style=color:#f92672>.</span><span style=color:#a6e22e>claim</span><span style=color:#f92672>())</span>
                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
            <span style=color:#75715e>// 2.3 没有定义线程池的情况下, 这里会同步执行任务 并设置任务的执行结果;                      
</span><span style=color:#75715e></span>                <span style=color:#75715e>// 任务封装UniApply不能处理完成该任务, 则在调用线程执行该任务, 并完成之;
</span><span style=color:#75715e></span>                <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>)</span> S s <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>S<span style=color:#f92672>)</span> r<span style=color:#f92672>;</span>
                completeValue<span style=color:#f92672>(</span>f<span style=color:#f92672>.</span><span style=color:#a6e22e>apply</span><span style=color:#f92672>(</span>s<span style=color:#f92672>));</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// 2.4 任务执行失败, 这里会设置任务异常;
</span><span style=color:#75715e></span>                <span style=color:#75715e>// 设置异常运行的结果;
</span><span style=color:#75715e></span>                completeThrowable<span style=color:#f92672>(</span>ex<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div></li><li><p>如果通过UniApply运行;
参考下面的异步执行部分;</p></li></ol><p>最后 thenApply 函数就能得到目标Future;</p><h3 id=异步执行>异步执行</h3><h4 id=示例-1>示例</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thenApplyAsyncExample</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>cf <span style=color:#f92672>=</span> CompletableFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>completedFuture</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;message&#34;</span><span style=color:#f92672>).</span><span style=color:#a6e22e>thenApplyAsync</span><span style=color:#f92672>(</span>s <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
    assertTrue<span style=color:#f92672>(</span>Thread<span style=color:#f92672>.</span><span style=color:#a6e22e>currentThread</span><span style=color:#f92672>().</span><span style=color:#a6e22e>isDaemon</span><span style=color:#f92672>());</span>
    randomSleep<span style=color:#f92672>();</span>
    returns<span style=color:#f92672>.</span><span style=color:#a6e22e>toUpperCase</span><span style=color:#f92672>();</span>
    <span style=color:#f92672>});</span>
    assertNull<span style=color:#f92672>(</span>cf<span style=color:#f92672>.</span><span style=color:#a6e22e>getNow</span><span style=color:#f92672>(</span><span style=color:#66d9ef>null</span><span style=color:#f92672>));</span>
    assertEquals<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;MESSAGE&#34;</span><span style=color:#f92672>,</span> cf<span style=color:#f92672>.</span><span style=color:#a6e22e>join</span><span style=color:#f92672>());</span>
<span style=color:#f92672>}</span>
</code></pre></div><h4 id=相关源码-1>相关源码</h4><ol><li><p>异步执行新的函数</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>thenApplyAsync</span><span style=color:#f92672>(</span>
        Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,?</span> <span style=color:#66d9ef>extends</span> U<span style=color:#f92672>&gt;</span> fn<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> uniApplyStage<span style=color:#f92672>(</span>asyncPool<span style=color:#f92672>,</span> fn<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
</code></pre></div></li><li><p>默认依赖的线程池定义如下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Default executor -- ForkJoinPool.commonPool() unless it cannot
</span><span style=color:#75715e>     * support parallelism.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Executor asyncPool <span style=color:#f92672>=</span> useCommonPool <span style=color:#f92672>?</span>
        ForkJoinPool<span style=color:#f92672>.</span><span style=color:#a6e22e>commonPool</span><span style=color:#f92672>()</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> ThreadPerTaskExecutor<span style=color:#f92672>();</span>

</code></pre></div></li><li><p>回在到同步异步兼容调度函数下</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>private</span> <span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>uniApplyStage</span><span style=color:#f92672>(</span>
        Executor e<span style=color:#f92672>,</span> Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,?</span> <span style=color:#66d9ef>extends</span> V<span style=color:#f92672>&gt;</span> f<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>f <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>();</span>
        <span style=color:#75715e>// 目标
</span><span style=color:#75715e></span>        CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> d <span style=color:#f92672>=</span>  <span style=color:#66d9ef>new</span> CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;();</span>
        <span style=color:#75715e>// 2. 执行目标过程 f
</span><span style=color:#75715e></span>        <span style=color:#75715e>// 两种情况 2.1. 定义了线程池e      2.2 再d中同步运行失败;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>e <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>d<span style=color:#f92672>.</span><span style=color:#a6e22e>uniApply</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> f<span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// 定义一个任务, 去线程池中e中, 针对线程池中this 中执行f 并输出到d中;
</span><span style=color:#75715e></span>            UniApply<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> c <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> UniApply<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;(</span>e<span style=color:#f92672>,</span> d<span style=color:#f92672>,</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> f<span style=color:#f92672>);</span>
            <span style=color:#75715e>// 将任务c押入栈中;
</span><span style=color:#75715e></span>            push<span style=color:#f92672>(</span>c<span style=color:#f92672>);</span>
            <span style=color:#75715e>//  触发任务完成;
</span><span style=color:#75715e></span>            c<span style=color:#f92672>.</span><span style=color:#a6e22e>tryFire</span><span style=color:#f92672>(</span>SYNC<span style=color:#f92672>);</span> <span style=color:#75715e>// 同步模式该方法返回null
</span><span style=color:#75715e></span>        <span style=color:#f92672>}</span>
        <span style=color:#75715e>/**
</span><span style=color:#75715e>         *   返回融合后的{@link CompletableFuture}
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>return</span> d<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div></li></ol><p>这里显然走2.1分支
将当前任务封装成UniApply&lt;T,V> 押入栈中后 并触发之;</p><ol start=4><li>UniApply 还是回到把任务的执行转发到目标 CompletableFuture (参数有函数和参数两部分)</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>
    <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;serial&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UniApply</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> UniCompletion<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
        Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,?</span> <span style=color:#66d9ef>extends</span> V<span style=color:#f92672>&gt;</span> fn<span style=color:#f92672>;</span>
        UniApply<span style=color:#f92672>(</span>Executor executor<span style=color:#f92672>,</span> CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> dep<span style=color:#f92672>,</span>
                 CompletableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> src<span style=color:#f92672>,</span>
                 Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,?</span> <span style=color:#66d9ef>extends</span> V<span style=color:#f92672>&gt;</span> fn<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>executor<span style=color:#f92672>,</span> dep<span style=color:#f92672>,</span> src<span style=color:#f92672>);</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>fn</span> <span style=color:#f92672>=</span> fn<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        <span style=color:#75715e>/**
</span><span style=color:#75715e>         *
</span><span style=color:#75715e>         * @param mode 指定触发模式;
</span><span style=color:#75715e>         * @return
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>final</span> CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>tryFire</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> mode<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// 依赖的完成器(目标)   ;   数据源来源
</span><span style=color:#75715e></span>            CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> d<span style=color:#f92672>;</span> CompletableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> a<span style=color:#f92672>;</span>
            <span style=color:#75715e>// 1. 运行, 运行失败直接返回null;
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>d <span style=color:#f92672>=</span> dep<span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span>
                <span style=color:#75715e>//2.  转发任务的执行到目标CompletableFuture: 只有异步才是null (该任务自己自身提交到线程池时这里为ASYNC == 1)
</span><span style=color:#75715e></span>                <span style=color:#f92672>!</span>d<span style=color:#f92672>.</span><span style=color:#a6e22e>uniApply</span><span style=color:#f92672>(</span>a <span style=color:#f92672>=</span> src<span style=color:#f92672>,</span> fn<span style=color:#f92672>,</span> mode <span style=color:#f92672>&gt;</span> 0 <span style=color:#f92672>?</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>))</span> <span style=color:#75715e>// 主要是执行 f.apply(a)
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
            <span style=color:#75715e>// 3. 运行成功 重置任务;
</span><span style=color:#75715e></span>            dep <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> src <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> fn <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
            <span style=color:#75715e>// 4. 再目标完成器中触发完成信号;
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> d<span style=color:#f92672>.</span><span style=color:#a6e22e>postFire</span><span style=color:#f92672>(</span>a<span style=color:#f92672>,</span> mode<span style=color:#f92672>);</span>  
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
</code></pre></div><ol start=5><li>如下可知 目标Future中运行时又通过claim函数转发给了, 任务定义UniApply</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * 从依赖的{@link CompletableFuture} 中获取结果, 再执行函数f, 并拿到结果给到当前的{@link CompletableFuture}
</span><span style=color:#75715e>     *
</span><span style=color:#75715e>     * @param a  数据来源 {@link CompletableFuture}
</span><span style=color:#75715e>     * @param f  即将引用的函数
</span><span style=color:#75715e>     * @param c
</span><span style=color:#75715e>     * @param &lt;S&gt;
</span><span style=color:#75715e>     * @return
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>final</span> <span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>uniApply</span><span style=color:#f92672>(</span>CompletableFuture<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>&gt;</span> a<span style=color:#f92672>,</span>
                               Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> S<span style=color:#f92672>,?</span> <span style=color:#66d9ef>extends</span> T<span style=color:#f92672>&gt;</span> f<span style=color:#f92672>,</span>
                               UniApply<span style=color:#f92672>&lt;</span>S<span style=color:#f92672>,</span>T<span style=color:#f92672>&gt;</span> c<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        Object r<span style=color:#f92672>;</span> Throwable x<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>a <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> <span style=color:#f92672>(</span>r <span style=color:#f92672>=</span> a<span style=color:#f92672>.</span><span style=color:#a6e22e>result</span><span style=color:#f92672>)</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> f <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>

        tryComplete: <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>result <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

            <span style=color:#75715e>// 1. 设置异常运行的结果;
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>r <span style=color:#66d9ef>instanceof</span> AltResult<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// 传播异常;
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>x <span style=color:#f92672>=</span> <span style=color:#f92672>((</span>AltResult<span style=color:#f92672>)</span>r<span style=color:#f92672>).</span><span style=color:#a6e22e>ex</span><span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                    completeThrowable<span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> r<span style=color:#f92672>);</span>
                    <span style=color:#66d9ef>break</span> tryComplete<span style=color:#f92672>;</span>
                <span style=color:#f92672>}</span>
                r <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
            <span style=color:#f92672>}</span>

            <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// 2. 没有定义线程池, 或者其判定已经或者被其他线程运行了;
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>c <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>c<span style=color:#f92672>.</span><span style=color:#a6e22e>claim</span><span style=color:#f92672>())</span> <span style=color:#75715e>// 在线程池中调用c.tryFire(mode)
</span><span style=color:#75715e></span>                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
                <span style=color:#75715e>// 3. 运行并设置结果;
</span><span style=color:#75715e></span>                <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;unchecked&#34;</span><span style=color:#f92672>)</span> S s <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>S<span style=color:#f92672>)</span> r<span style=color:#f92672>;</span>
                completeValue<span style=color:#f92672>(</span>f<span style=color:#f92672>.</span><span style=color:#a6e22e>apply</span><span style=color:#f92672>(</span>s<span style=color:#f92672>));</span>
            <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>Throwable ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// 4. 设置异常运行的结果;
</span><span style=color:#75715e></span>                completeThrowable<span style=color:#f92672>(</span>ex<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div><ol start=6><li><p>claim 函数在UniApply的基类里面：</p><ol><li>其保证该任务仅能被执行一次;</li><li>如果当前任务有设定线程池，则claim函数会将自己提交到自己的线程池里面，<ol><li>任务会让依赖的CompletableFuture#uniApply执行, 不过此时第三个参数 UniApply&lt;S,T> 为null,所以其会执行运行apply函数;</li></ol></li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UniCompletion</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> Completion <span style=color:#f92672>{</span>
        Executor executor<span style=color:#f92672>;</span>                 <span style=color:#75715e>// executor to use (null if none) 执行器;
</span><span style=color:#75715e></span>        CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> dep<span style=color:#f92672>;</span>          <span style=color:#75715e>// the dependent to complete  依赖的完成器;
</span><span style=color:#75715e></span>        CompletableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> src<span style=color:#f92672>;</span>          <span style=color:#75715e>// source for action  数据源;
</span><span style=color:#75715e></span>
        UniCompletion<span style=color:#f92672>(</span>Executor executor<span style=color:#f92672>,</span> CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> dep<span style=color:#f92672>,</span>
                      CompletableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> src<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>executor</span> <span style=color:#f92672>=</span> executor<span style=color:#f92672>;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>dep</span> <span style=color:#f92672>=</span> dep<span style=color:#f92672>;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>src</span> <span style=color:#f92672>=</span> src<span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        <span style=color:#75715e>/**
</span><span style=color:#75715e>         * Returns true if action can be run. Call only when known to
</span><span style=color:#75715e>         * be triggerable. Uses FJ tag bit to ensure that only one
</span><span style=color:#75715e>         * thread claims ownership.  If async, starts as task -- a
</span><span style=color:#75715e>         * later call to tryFire will run action.
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>claim</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            Executor e <span style=color:#f92672>=</span> executor<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>compareAndSetForkJoinTaskTag<span style=color:#f92672>((</span><span style=color:#66d9ef>short</span><span style=color:#f92672>)</span>0<span style=color:#f92672>,</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>short</span><span style=color:#f92672>)</span>1<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// 没有线程池, 则只修改了运行标示, 并不返回true;
</span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>e <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
                    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
                executor <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> <span style=color:#75715e>// disable
</span><span style=color:#75715e></span>                <span style=color:#75715e>// 在线程池中运行当前任务;
</span><span style=color:#75715e></span>                e<span style=color:#f92672>.</span><span style=color:#a6e22e>execute</span><span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
            <span style=color:#75715e>// 当前action不能再被运行;
</span><span style=color:#75715e></span>            <span style=color:#75715e>// 1. 修改标识位失败: 其他线程去运行了;
</span><span style=color:#75715e></span>            <span style=color:#75715e>// 2. 修改标识位成功: 但是存在线程池, 因此去线程池中运行了.
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span><span style=color:#f92672>;</span>
        <span style=color:#f92672>}</span>

        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isLive</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> dep <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>

</code></pre></div></li><li><p>任务定义更是在基类里面</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#75715e>// Modes for Completion.tryFire. Signedness matters.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> SYNC   <span style=color:#f92672>=</span>  0<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> ASYNC  <span style=color:#f92672>=</span>  1<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> NESTED <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1<span style=color:#f92672>;</span>

    <span style=color:#a6e22e>@SuppressWarnings</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;serial&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Completion</span> <span style=color:#66d9ef>extends</span> ForkJoinTask<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span>
        <span style=color:#66d9ef>implements</span> Runnable<span style=color:#f92672>,</span> AsynchronousCompletionTask <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>volatile</span> Completion next<span style=color:#f92672>;</span>      <span style=color:#75715e>// Treiber stack link
</span><span style=color:#75715e></span>
        <span style=color:#75715e>/**
</span><span style=color:#75715e>         * Performs completion action if triggered, returning a
</span><span style=color:#75715e>         * dependent that may need propagation, if one exists.
</span><span style=color:#75715e>         *
</span><span style=color:#75715e>         * @param mode SYNC, ASYNC, or NESTED
</span><span style=color:#75715e>         */</span>
        <span style=color:#66d9ef>abstract</span> CompletableFuture<span style=color:#f92672>&lt;?&gt;</span> tryFire<span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> mode<span style=color:#f92672>);</span>

        <span style=color:#75715e>/** Returns true if possibly still triggerable. Used by cleanStack. */</span>
        <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isLive</span><span style=color:#f92672>();</span>

        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span>                <span style=color:#f92672>{</span> tryFire<span style=color:#f92672>(</span>ASYNC<span style=color:#f92672>);</span> <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>exec</span><span style=color:#f92672>()</span>            <span style=color:#f92672>{</span> tryFire<span style=color:#f92672>(</span>ASYNC<span style=color:#f92672>);</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Void <span style=color:#a6e22e>getRawResult</span><span style=color:#f92672>()</span>       <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span> <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setRawResult</span><span style=color:#f92672>(</span>Void v<span style=color:#f92672>)</span> <span style=color:#f92672>{}</span>
    <span style=color:#f92672>}</span>

</code></pre></div><p>如上UniApply最后又通过tryFire(ASYNC) 再一次将运行代码路由到了UniApply
只是这次是同步模式;
接下来就是如同步章节的处理过程;</p><p>注意这两次tryFire调用</p><ol><li>同步/异步模式: 会返回null</li><li>NEST模式 在目标CompletableFuture中返回, 其会返回自身;</li></ol></li><li><p>由5.3 , 4.4可知任务完成后, 将通知相关等待方;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JAVA data-lang=JAVA>    <span style=color:#75715e>/**
</span><span style=color:#75715e>     * Post-processing by dependent after successful UniCompletion
</span><span style=color:#75715e>     * tryFire.  Tries to clean stack of source a, and then either runs
</span><span style=color:#75715e>     * postComplete or returns this to caller, depending on mode.
</span><span style=color:#75715e>     */</span>
    <span style=color:#66d9ef>final</span> CompletableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>postFire</span><span style=color:#f92672>(</span>CompletableFuture<span style=color:#f92672>&lt;?&gt;</span> a<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> mode<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>

        <span style=color:#75715e>// 数据来源a 能够拿到结果, 
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>a <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> a<span style=color:#f92672>.</span><span style=color:#a6e22e>stack</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// 
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mode <span style=color:#f92672>&lt;</span> 0 <span style=color:#f92672>||</span> a<span style=color:#f92672>.</span><span style=color:#a6e22e>result</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
                a<span style=color:#f92672>.</span><span style=color:#a6e22e>cleanStack</span><span style=color:#f92672>();</span>
            <span style=color:#66d9ef>else</span>
                a<span style=color:#f92672>.</span><span style=color:#a6e22e>postComplete</span><span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>// 当前数据源得到结果, 则可以提交该任务; 
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>result <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span> stack <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            <span style=color:#75715e>// 级联模式返回自己;
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>mode <span style=color:#f92672>&lt;</span> 0<span style=color:#f92672>)</span>
                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>;</span>
            <span style=color:#75715e>// 触发自己的监听任务;  
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>else</span>
                postComplete<span style=color:#f92672>();</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div></li></ol><h3 id=使用固定的线程池完成异步执行动作示例>使用固定的线程池完成异步执行动作示例</h3><h3 id=全部完成则响应>全部完成则响应</h3><h4 id=入口代码>入口代码:</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JAVA data-lang=JAVA>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>allOf</span><span style=color:#f92672>(</span>CompletableFuture<span style=color:#f92672>&lt;?&gt;...</span> cfs<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> andTree<span style=color:#f92672>(</span>cfs<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> cfs<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
</code></pre></div><h4 id=递归计算>递归计算</h4><p>如下使用递归的方式构建节点树:</p><p>andTree 会将所有的 Future 构建一颗二叉树, 最终返回根节点.</p><ol><li>每个节点的完成都会依赖或者由其孩子节点触发;<ol><li>每个孩子通过自己监听队列中的 Completion#tryFire(int mode) 触发父亲的 biRelay 方法</li><li>但是当前节点的 biRelay 方法, 依赖每个节点的完成，才完成，并触发postFire方法, 将完成信号级联传播到父亲节点;</li></ol></li></ol><p>递归重复子过程:</p><ol><li>构建依赖(输出) Future: d</li><li>使用二分法切分左右子树到节点 a、b</li><li>封装依赖d(当前节点)和被依赖a、b到 BiRelay, 并将后者压入a、b的栈中, 后期即可接受它们的回调, 能够达到回溯的效果;</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JAVA data-lang=JAVA>
    <span style=color:#66d9ef>static</span> CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>andTree</span><span style=color:#f92672>(</span>CompletableFuture<span style=color:#f92672>&lt;?&gt;[]</span> cfs<span style=color:#f92672>,</span>
                                           <span style=color:#66d9ef>int</span> lo<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> hi<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#75715e>// 当前需要构建的节点 d; 它将依赖子任务的运行完成, 并能够响应子任务的完成信号;                                                                                 
</span><span style=color:#75715e></span>        CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> d <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;();</span>
        <span style=color:#75715e>// 1. 递归边界条件, 当前节点直接完成; 
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>lo <span style=color:#f92672>&gt;</span> hi<span style=color:#f92672>)</span> <span style=color:#75715e>// empty
</span><span style=color:#75715e></span>            d<span style=color:#f92672>.</span><span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> NIL<span style=color:#f92672>;</span>
        <span style=color:#75715e>// 2. 构建当前节点d 依赖, 其孩子节点的完成;  
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
            CompletableFuture<span style=color:#f92672>&lt;?&gt;</span> a<span style=color:#f92672>,</span> b<span style=color:#f92672>;</span>
            <span style=color:#75715e>// 2.1 中点
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>lo <span style=color:#f92672>+</span> hi<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;&gt;&gt;</span> 1<span style=color:#f92672>;</span>
            <span style=color:#75715e>// 2.2 递归封装左子树
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>a <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>lo <span style=color:#f92672>==</span> mid <span style=color:#f92672>?</span> cfs<span style=color:#f92672>[</span>lo<span style=color:#f92672>]</span> <span style=color:#f92672>:</span>
                      andTree<span style=color:#f92672>(</span>cfs<span style=color:#f92672>,</span> lo<span style=color:#f92672>,</span> mid<span style=color:#f92672>)))</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> 
                <span style=color:#75715e>// 递归封装右子树                    
</span><span style=color:#75715e></span>                <span style=color:#f92672>(</span>b <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>lo <span style=color:#f92672>==</span> hi <span style=color:#f92672>?</span> a <span style=color:#f92672>:</span> <span style=color:#f92672>(</span>hi <span style=color:#f92672>==</span> mid<span style=color:#f92672>+</span>1<span style=color:#f92672>)</span> <span style=color:#f92672>?</span> cfs<span style=color:#f92672>[</span>hi<span style=color:#f92672>]</span> <span style=color:#f92672>:</span>
                      andTree<span style=color:#f92672>(</span>cfs<span style=color:#f92672>,</span> mid<span style=color:#f92672>+</span>1<span style=color:#f92672>,</span> hi<span style=color:#f92672>)))</span>  <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>();</span>

            <span style=color:#75715e>//  2.3 组合左右子树, 让当前节点检测依赖的两个孩子, 如果两个孩子没有完成
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>d<span style=color:#f92672>.</span><span style=color:#a6e22e>biRelay</span><span style=color:#f92672>(</span>a<span style=color:#f92672>,</span> b<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
                <span style=color:#75715e>// 2.3.1 创建一个 BiCompletion, 它会封装d并代表 d 加入 a和b 的等待队列;
</span><span style=color:#75715e></span>                BiRelay<span style=color:#f92672>&lt;?,?&gt;</span> c <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BiRelay<span style=color:#f92672>&lt;&gt;(</span>d<span style=color:#f92672>,</span> a<span style=color:#f92672>,</span> b<span style=color:#f92672>);</span>
                <span style=color:#75715e>// 2.3.2 将 c 加入a和b的等待队列;
</span><span style=color:#75715e></span>                a<span style=color:#f92672>.</span><span style=color:#a6e22e>bipush</span><span style=color:#f92672>(</span>b<span style=color:#f92672>,</span> c<span style=color:#f92672>);</span>
                <span style=color:#75715e>// 2.3.3 BiCompletion c 让 组合Future d 去尝试检测其依赖Future的完成结果, 如果完成则通知自己的等待列表;
</span><span style=color:#75715e></span>                c<span style=color:#f92672>.</span><span style=color:#a6e22e>tryFire</span><span style=color:#f92672>(</span>SYNC<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#75715e>// 3. 触发 Future 的完成;
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> d<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div><h3 id=任意完成则完成>任意完成则完成</h3><h4 id=入口代码-1>入口代码</h4><p>根据输入的 future 构建递归树, 根节点就是输出的CompletableFuture;</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> CompletableFuture<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>anyOf</span><span style=color:#f92672>(</span>CompletableFuture<span style=color:#f92672>&lt;?&gt;...</span> cfs<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>return</span> orTree<span style=color:#f92672>(</span>cfs<span style=color:#f92672>,</span> 0<span style=color:#f92672>,</span> cfs<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span> <span style=color:#f92672>-</span> 1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
</code></pre></div><ol><li>封装依赖节点d, 被依赖节点a，b为任务 OrRelay</li><li>将任务输出到依赖节点a，b 相当于加入它们的订阅列表;</li><li>依赖任务执行完毕后会通知/回溯到依赖节点;</li></ol><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>    <span style=color:#75715e>/** Recursively constructs a tree of completions. */</span>
    <span style=color:#66d9ef>static</span> CompletableFuture<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>orTree</span><span style=color:#f92672>(</span>CompletableFuture<span style=color:#f92672>&lt;?&gt;[]</span> cfs<span style=color:#f92672>,</span>
                                            <span style=color:#66d9ef>int</span> lo<span style=color:#f92672>,</span> <span style=color:#66d9ef>int</span> hi<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        CompletableFuture<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;</span> d <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CompletableFuture<span style=color:#f92672>&lt;</span>Object<span style=color:#f92672>&gt;();</span>
        <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>lo <span style=color:#f92672>&lt;=</span> hi<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
            CompletableFuture<span style=color:#f92672>&lt;?&gt;</span> a<span style=color:#f92672>,</span> b<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>int</span> mid <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>lo <span style=color:#f92672>+</span> hi<span style=color:#f92672>)</span> <span style=color:#f92672>&gt;&gt;&gt;</span> 1<span style=color:#f92672>;</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>((</span>a <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>lo <span style=color:#f92672>==</span> mid <span style=color:#f92672>?</span> cfs<span style=color:#f92672>[</span>lo<span style=color:#f92672>]</span> <span style=color:#f92672>:</span>
                      orTree<span style=color:#f92672>(</span>cfs<span style=color:#f92672>,</span> lo<span style=color:#f92672>,</span> mid<span style=color:#f92672>)))</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span>
                <span style=color:#f92672>(</span>b <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>lo <span style=color:#f92672>==</span> hi <span style=color:#f92672>?</span> a <span style=color:#f92672>:</span> <span style=color:#f92672>(</span>hi <span style=color:#f92672>==</span> mid<span style=color:#f92672>+</span>1<span style=color:#f92672>)</span> <span style=color:#f92672>?</span> cfs<span style=color:#f92672>[</span>hi<span style=color:#f92672>]</span> <span style=color:#f92672>:</span>
                      orTree<span style=color:#f92672>(</span>cfs<span style=color:#f92672>,</span> mid<span style=color:#f92672>+</span>1<span style=color:#f92672>,</span> hi<span style=color:#f92672>)))</span>  <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException<span style=color:#f92672>();</span>
            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(!</span>d<span style=color:#f92672>.</span><span style=color:#a6e22e>orRelay</span><span style=color:#f92672>(</span>a<span style=color:#f92672>,</span> b<span style=color:#f92672>))</span> <span style=color:#f92672>{</span>
                OrRelay<span style=color:#f92672>&lt;?,?&gt;</span> c <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> OrRelay<span style=color:#f92672>&lt;&gt;(</span>d<span style=color:#f92672>,</span> a<span style=color:#f92672>,</span> b<span style=color:#f92672>);</span>
                a<span style=color:#f92672>.</span><span style=color:#a6e22e>orpush</span><span style=color:#f92672>(</span>b<span style=color:#f92672>,</span> c<span style=color:#f92672>);</span>
                c<span style=color:#f92672>.</span><span style=color:#a6e22e>tryFire</span><span style=color:#f92672>(</span>SYNC<span style=color:#f92672>);</span>
            <span style=color:#f92672>}</span>
        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> d<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
</code></pre></div><h2 id=参考>参考</h2><ol><li><a href=https://colobu.com/2016/02/29/Java-CompletableFuture/>鸟窝</a></li><li><a href=https://developer.ibm.com/zh/articles/j-cf-of-jdk8/>IBM-通过实例理解 JDK8 的 CompletableFuture</a></li><li><a href=http://youngitman.tech/2019/02/13/completablefuture%E6%BA%90%E7%A0%81/>youngitman</a></li><li><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html>oracle</a></li></ol></div></article></main><div class="authorbox clearfix"><figure class=authorbox__avatar><img alt="Halley avatar" src=/halley/img/avatar.png class=avatar height=90 width=90></figure><div class=authorbox__header><span class=authorbox__name>About Halley</span></div><div class=authorbox__description>I&rsquo;am interest in compute sience</div></div><nav class="pager flex"><div class="pager__item pager__item--next"><a class=pager__link href=/halley/jdk/%E9%9B%86%E5%90%88%E5%8C%85/ rel=next><span class=pager__subtitle>Next&#8201;»</span><p class=pager__title>集合包</p></a></div></nav></div><aside class=sidebar><div class="widget-search widget"><form class=widget-search__form role=search method=get action=https://google.com/search><label><input class=widget-search__field type=search placeholder=SEARCH... name=q aria-label=SEARCH...></label>
<input class=widget-search__submit type=submit value=Search>
<input type=hidden name=sitesearch value=https://halley-eng.github.io/halley/></form></div><div class="widget-recent widget"><h4 class=widget__title>Recent Posts</h4><div class=widget__content><ul class=widget__list><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E9%A2%98%E7%9B%AE/>回溯题目</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/>螺旋矩阵</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E9%A2%98%E7%9B%AE%E7%AF%87/>分治题目篇</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E6%89%91%E5%85%8B%E7%89%8C%E9%97%AE%E9%A2%98/>扑克牌问题</a></li><li class=widget__item><a class=widget__link href=/halley/%E7%AE%97%E6%B3%95/%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B1%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F_1356/>根据数字二进制下1的数目排序_1356</a></li></ul></div></div><div class="widget-taglist widget"><h4 class=widget__title>Tags</h4><div class=widget__content><a class="widget-taglist__link widget__link btn" href=/halley/tags/mybatis/ title=mybatis>mybatis</a>
<a class="widget-taglist__link widget__link btn" href=/halley/tags/shardingspare/ title=shardingspare>shardingspare</a>
<a class="widget-taglist__link widget__link btn" href=/halley/tags/spring/ title=spring>spring</a>
<a class="widget-taglist__link widget__link btn" href=/halley/tags/spring-boot/ title=spring-boot>spring-boot</a></div></div></aside></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2020 月亮.
<span class=footer__copyright-credits>Generated with <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> and <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> theme.</span></div></div></footer></div><script async defer src=/halley/js/menu.js></script></body></html>