<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>spring on 月亮</title><link>https://halley-eng.github.io/halley/tags/spring/</link><description>Recent content in spring on 月亮</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Tue, 22 Dec 2020 21:39:16 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/tags/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>Configuration注解之ConfigurationClassPostProcessor</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/configuration%E6%B3%A8%E8%A7%A3%E4%B9%8Bconfigurationclasspostprocessor/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/configuration%E6%B3%A8%E8%A7%A3%E4%B9%8Bconfigurationclasspostprocessor/</guid><description>运行时机 BeanDefinitionRegistryPostProcessor 钩子 通过实现 BeanDefinitionRegistryPostProcessor 接口, 可以在IOC容器刷新阶段的调用, 如下方法
/** * Derive further bean definitions from the configuration classes in the registry. */ @Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) { // 1. 保证IOC容器只能处理一次; int registryId = System.identityHashCode(registry); if (this.registriesPostProcessed.contains(registryId)) { throw new IllegalStateException( &amp;#34;postProcessBeanDefinitionRegistry already called on this post-processor against &amp;#34; + registry); } if (this.factoriesPostProcessed.contains(registryId)) { throw new IllegalStateException( &amp;#34;postProcessBeanFactory already called on this post-processor against &amp;#34; + registry); } this.</description></item><item><title>JdbcTemplate相关源码</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/jdbctemplate%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/jdbctemplate%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81/</guid><description>JdbcTemplate 相关源码 数据行映射到对象 BeanPropertyRowMapper#mapRow /** * Extract the values for all columns in the current row. * &amp;lt;p&amp;gt;Utilizes public setters and result set meta-data. * @see java.sql.ResultSetMetaData */ @Override public T mapRow(ResultSet rs, int rowNumber) throws SQLException { // 1. 构建并初始化BeanWrapper BeanWrapperImpl bw = new BeanWrapperImpl(); initBeanWrapper(bw); // 2. 构建实例; T mappedObject = constructMappedInstance(rs, bw); // 3. 封装到 Spring 的BeanWrapper bw.setBeanInstance(mappedObject); // 4. 循环解析每一列到BeanWrapper; ResultSetMetaData rsmd = rs.</description></item><item><title>SpringFramework之AutowiredAnnotationBeanPostProcessor</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/springframework%E4%B9%8Bautowiredannotationbeanpostprocessor/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/springframework%E4%B9%8Bautowiredannotationbeanpostprocessor/</guid><description>支持注入的注解类型 从如下构造方法可知其支持的给两种注解类型
Autowired Value /** * Create a new AutowiredAnnotationBeanPostProcessor * for Spring&amp;#39;s standard {@link Autowired} annotation. * &amp;lt;p&amp;gt;Also supports JSR-330&amp;#39;s {@link javax.inject.Inject} annotation, if available. */ @SuppressWarnings(&amp;#34;unchecked&amp;#34;) public AutowiredAnnotationBeanPostProcessor() { this.autowiredAnnotationTypes.add(Autowired.class); this.autowiredAnnotationTypes.add(Value.class); try { this.autowiredAnnotationTypes.add((Class&amp;lt;? extends Annotation&amp;gt;) ClassUtils.forName(&amp;#34;javax.inject.Inject&amp;#34;, AutowiredAnnotationBeanPostProcessor.class.getClassLoader())); logger.trace(&amp;#34;JSR-330 &amp;#39;javax.inject.Inject&amp;#39; annotation found and supported for autowiring&amp;#34;); } catch (ClassNotFoundException ex) { // JSR-330 API not available - simply skip. } } 注入的时机 Value 注解和 Autowire 都是由 AutowiredAnnotationBeanPostProcessor 负责解析依赖并注入的 但是Value的数据源为需要手动注册 PropertySourcesPlaceholderConfigurer</description></item><item><title>Spring注解解析</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/</guid><description>Spring 解析注解 注解中的属性方法定义 AttributeMethods#isAttributeMethod
/** * 属性方法的定义是 无参数 有返回值得方法; * @param method * @return */ private static boolean isAttributeMethod(Method method) { return (method.getParameterCount() == 0 &amp;amp;&amp;amp; method.getReturnType() != void.class); } 获取注解中的所有属性方法 private static AttributeMethods compute(Class&amp;lt;? extends Annotation&amp;gt; annotationType) { // 1. 收集所有方法 Method[] methods = annotationType.getDeclaredMethods(); int size = methods.length; // 2. 过滤得到属性方法; for (int i = 0; i &amp;lt; methods.length; i++) { if (!isAttributeMethod(methods[i])) { methods[i] = null; size--; } } if (size == 0) { return NONE; } // 3.</description></item><item><title>Spring解析Configuration类</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E8%A7%A3%E6%9E%90configuration%E7%B1%BB/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/spring%E8%A7%A3%E6%9E%90configuration%E7%B1%BB/</guid><description>解析所有配置类 ConfigurationClassParser#parse(Set)
public void parse(Set&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates) { // 1. 扫描所有配置类; for (BeanDefinitionHolder holder : configCandidates) { BeanDefinition bd = holder.getBeanDefinition(); try { // 1.1 带注解的解析; if (bd instanceof AnnotatedBeanDefinition) { parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName()); } // 1.2 else if (bd instanceof AbstractBeanDefinition &amp;amp;&amp;amp; ((AbstractBeanDefinition) bd).hasBeanClass()) { parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName()); } // 1.3 else { parse(bd.getBeanClassName(), holder.getBeanName()); } } catch (BeanDefinitionStoreException ex) { throw ex; } catch (Throwable ex) { throw new BeanDefinitionStoreException( &amp;#34;Failed to parse configuration class [&amp;#34; + bd.</description></item><item><title>注解EnableTransactionManagement自动导入事务管理器</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E6%B3%A8%E8%A7%A3enabletransactionmanagement%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E6%B3%A8%E8%A7%A3enabletransactionmanagement%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/</guid><description>事务注解的解析流程
ConfigurationClassPostProcessor 解析配置类 发现注解类型 EnableTransactionManagement 根据注解找到其对应的 Selector 实现 TransactionManagementConfigurationSelector 解析器调用 selector 实现父类 AdviceModeImportSelector 的 selectImports(AnnotationMetadata importingClassMetadata)方法 AdviceModeImportSelector 解析出通知模式后 调用selector实现类 的 selectImports(AdviceMode adviceMode) 第四部源码如下:
根据通知模式模式(AspectJ/Proxy)路由不同的配置类; AdviceModeImportSelector#selectImports(AnnotationMetadata)
@Override public final String[] selectImports(AnnotationMetadata importingClassMetadata) { // 1. 查询当前类作为别人的父类是, 子类给的泛型参数是什么, 它是当前类要处理的注解类型; Class&amp;lt;?&amp;gt; annoType = GenericTypeResolver.resolveTypeArgument(getClass(), AdviceModeImportSelector.class); // 2. 从源配置类中查询出来, 注解参数实际对象; AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(importingClassMetadata, annoType); if (attributes == null) { throw new IllegalArgumentException(String.format( &amp;#34;@%s is not present on importing class &amp;#39;%s&amp;#39; as expected&amp;#34;, annoType.</description></item></channel></rss>