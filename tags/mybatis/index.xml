<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mybatis on 月亮</title><link>https://halley-eng.github.io/halley/tags/mybatis/</link><description>Recent content in mybatis on 月亮</description><generator>Hugo -- gohugo.io</generator><language>zh_CN</language><lastBuildDate>Tue, 22 Dec 2020 21:39:16 +0800</lastBuildDate><atom:link href="https://halley-eng.github.io/halley/tags/mybatis/index.xml" rel="self" type="application/rss+xml"/><item><title>mybatis源码</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E6%BA%90%E7%A0%81/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E6%BA%90%E7%A0%81/</guid><description>Mapper代理创建 org.mybatis.spring.mapper.MapperFactoryBean#getObject
@Override public T getObject() throws Exception { return getSqlSession().getMapper(this.mapperInterface); } 这里的配置通常是 SqlSessionTemplate 它是 spring-mybatis 实现的线程安全会话创建和生命周期管理类;
后期 SqlSession 的方法都会通过他的拦截器 SqlSessionTemplate.SqlSessionInterceptor 详细如下:
Sql Session 拦截器接收sql参数并执行 SqlSessionTemplate.SqlSessionInterceptor
该拦截器负责
封装 SqlSession 的获取 调用 SqlSession 的相关方法，完成sql执行的生命周期; private class SqlSessionInterceptor implements InvocationHandler { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 1. 获取会话 SqlSession sqlSession = getSqlSession( SqlSessionTemplate.this.sqlSessionFactory, // 每个工厂么每个线程都能仅能找到唯一一个 SqlSession SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); try { // 2.</description></item><item><title>mybatis解析xml和动态sql</title><link>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E8%A7%A3%E6%9E%90xml%E5%92%8C%E5%8A%A8%E6%80%81sql/</link><pubDate>Tue, 22 Dec 2020 21:39:16 +0800</pubDate><guid>https://halley-eng.github.io/halley/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/mybatis%E8%A7%A3%E6%9E%90xml%E5%92%8C%E5%8A%A8%E6%80%81sql/</guid><description>mybatis 如何解析xml文件 support.DaoSupport#afterPropertiesSet MapperFactoryBean#checkDaoConfig 总之， MapperFactoryBean该工厂bean初始化后就会注册到 MapperRegistry org.apache.ibatis.binding.MapperRegistry#addMapper 在触发解析xml MapperAnnotationBuilder#parse MapperAnnotationBuilder#loadXmlResource MapperBuilderAssistant#addMappedStatement
动态sql解析 DynamicSqlSource#getBoundSql
根据参数解析动态sql生成 BoundSql
public BoundSql getBoundSql(Object parameterObject) { BoundSql boundSql = sqlSource.getBoundSql(parameterObject); List&amp;lt;ParameterMapping&amp;gt; parameterMappings = boundSql.getParameterMappings(); if (parameterMappings == null || parameterMappings.isEmpty()) { boundSql = new BoundSql(configuration, boundSql.getSql(), parameterMap.getParameterMappings(), parameterObject); } // check for nested result maps in parameter mappings (issue #30) for (ParameterMapping pm : boundSql.getParameterMappings()) { String rmId = pm.getResultMapId(); if (rmId != null) { ResultMap rm = configuration.</description></item></channel></rss>